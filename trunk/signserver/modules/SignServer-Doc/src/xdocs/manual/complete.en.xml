<?xml version="1.0"?>
<!-- $Id$ -->

<document>

    <properties>
        <title>SignServer Manual</title>
    </properties>

    <body>

        <chapter name="Introduction" shortname="introduction">
            <section name="Introduction/scope">
                <p>
The SignServer is an application framework performing cryptographic operations
for other applications. It's intended to be used in environments where keys are
supposed to be protected in hardware but it isn't possible to connect such
hardware to existing enterprise applications or where the operations are
considered extra sensitive so the hardware have to protected more carefully.
Another usage is to provide a simplified method to provide signatures in
different application managed from one location in the company.
                </p>
                <p>
The SignServer have been designed for high-availability and can be clustered for maximum
reliability.
                </p>
                <p>
The SignServer comes with a RFC 3161 compliant Time-Stamp signer serving requests through
HTTP or client-authenticated HTTPS. A MRTD (Machine Readable Travel Document, i.e. electronic
passport) signer. A PDF signer that adds a signature automatically to a uploaded PDF document,
ODF signer that adds a signature automatically to uploaded ODF document, OOXML Signer that
adds signature automatically to a uploaded OOXML document, and a validation service used to
lookup the validation of a given certificate.
                </p>
                <p>
                    <a href="../images/architecture.png"><img src="../images/architecture.png" align="middle" border="0" width="641" height="305" ALT="architecture"/></a><br/>
                    Drawing 1: Overview of a possible set up of a highly available SignServer solution
                </p>
            </section>

            <section name="Changes from previous versions">
                <subsection name="Changes between version 3.2 and 3.3">
                    <ul>
<!-- New major features -->
                        <li>New client web services API</li>
                        <li>MS Authenticode time-stamp signer</li>
                        <li>Support for archiving of time-stamp requests</li>
                        <li>Logging of all changes to service components</li>
                        <li>Stress test tool for measuring performance</li>
                        <li>Dropped support for JBoss 4.2.x.</li>
                        <li>Dropped support for cluster class loader</li>
                        <li>Dropped support for WSRA</li>
                        <li>Upgrade of cryptographic library</li>
                        <li>Many more minor changes and bug fixes. See 
                            ChangeLog.txt and RELASE_NOTES.txt for details.</li>
                    </ul>
                </subsection>
                <subsection name="Changes between version 3.1 and 3.2">
                    <ul>
<!-- New major features -->
                        <li>
A new administration web service (WS) for remote administration of SignServer.
                        </li>

                        <li>
A new administration GUI desktop application for managing workers. Supports
key generation and both local and remote administration.
                        </li>

                        <li>
A new client command line interface (CLI) for requesting signing and validation.
                        </li>

<!-- New support -->
                        <li>
Support for GlassFish Server 2.1.1.
                        </li>
                        <li>
Support for JBoss Application Server 5.1.
                        </li>

                        <li>
Support for Oracle Database.
                        </li>

<!-- New workers -->
                        <li>
Worker renewing signers by generating new keys and sending certificate requests
to EJBCA.
                        </li>

<!-- Improvements -->
                        <li>
Better audit and transaction logging.
                        </li>
                        <li>
New build scripts and project structure with the goal of decouple the different
SignServer modules and sub-projects and simplify future development.
                        </li>
                        <li>
Front page listing all demo web pages.
                        </li>

<!-- Other -->
                        <li>
The bundled SMTP server and MailSigner build of SignServer has been removed.
                        </li>

                    </ul>
                </subsection>
                <subsection name="Changes between version 3.0 and 3.1">
                    <ul>
                        <li>
A new Cluster Class Loader, simplifying the management of customized workers in a
cluster. All the resource data including the classes themselves are stored in database and
accessible from all nodes simultaneously. It is also possible to run multiple versions of the
same worker in the same SignServer cluster, this is useful when migrating a worker to new
code since both the old and new worker can be run at the same time.
                        </li>
                        <li>
PDF Signer, Time-Stamp Authority and MRTD and their specific libraries have the
possibility to build into separate module archives (MAR files) that have to be uploaded to
the SignServer installation before usage, if the cluster classloader is enabled (default).
                        </li>
                        <li>
Installation packages for Linux/Windows of both SignServer and MailSigner using
generation software from Bitrock.
                        </li>
                        <li>
New extended module for signing ePassports: MRTD-SOD.
                        </li>
                        <li>
New modules for signing and validating XML documents.
                        </li>
                        <li>
A new ODF Signer module that adds signature to ODF documents, such as : odt,ods,odt
(tested with OpenOffice.org 3.1.0). Simple web page is added where ODF document can be
uploaded for signing, and resulted signed document downloaded.
                        </li>
                        <li>
A new OOXML Signer Module that adds signature to Office Open XML documents, such as
docx,xlsx,pptx (tested with Microsoft Office 2007).Simple web page is added where open
office xml document can be uploaded for signing, and resulted signed document
downloaded.
                        </li>
                        <li>
Validators for several document types as well.
                        </li>
                        <li>
Java 5 is no longer supported.
                        </li>
                        <li>
For minor changes see the change log at http://jira.primekey.se
                        </li>
                </ul>
                </subsection>
                <subsection name="Changes between version 2 and 3">
                    <ul>
                        <li>
Complete refactorisation of J2EE from EJB2 to EJB3 to simplify further development.
                        </li>
                        <li>
Renamed component "Service" to "TimedService" since 3.0 supports other services.
                        </li>
                        <li>
A "TimedService" can now be configured with a 'cron-like' settings to have services
executed in other than just periodical intervals.
                        </li>
                        <li>
A Validation Service API used to validate certificate from different issuers. The Validation
Service API have it's own easy to use Web Service used to integrate with other platforms.
A Group Key Service API used to generate and manage group keys, symmetric or
asymmetric.
                        </li>
                        <li>
Possibility to have customized authorization of requests, not just the built in client certificate
authorization list.
                        </li>
                        <li>
The name SignToken is changed to CryptoToken and introduced a new concept of
ExtendedCryptoToken that supports symmetric operations.
                        </li>
                        <li>
The RMI-SSL interface have been removed and replaced with a JAX-WS interface with a
simple client framework supporting different load-balance or high availability policies.
                        </li>
                        <li>
All request data have changed from serialization to externalization to be easier to translate to
other platforms.
                        </li>
                        <li>
A completely new MailSigner API based upon the JAMES SMTP server to perform
automated cryptographic operations on e-mails very similar to the plug-ins for the
SignServer.
                        </li>
                        <li>
Java 1.4 is no longer supported.
                        </li>
                        <li>
A lot of new JUnit tests in the test suite.
                        </li>
                        <li>
A PDF Signer that can add a signature to a PDF document through a simple HTML
interface.
                        </li>
                        <li>
PKCS11 Crypto Token to connect to different PKCS11 implementations.
                        </li>
                    </ul>
                </subsection>
                <subsection name="Changes between version 1 and 2">
                    <ul>
                        <li>
  signserver_server.property file have been removed and replaced with a global configuration
  store.
                        </li>
                        <li>
  It is now possible to dynamically add and remove available signers
                        </li>
                        <li>
  A new type of component, "Service" that is run on a timely basis, used to perform
  maintenance or report generation.
                        </li>
                        <li>
  Improved cluster deployment functionality.
                        </li>
                        <li>
  New CLI tools to batch configure the SignServer, and to backup a current configuration.
                        </li>
                        <li>
  This makes it possible to set-up a configuration in test environment, dump the configuration
  and configure the same it in production.
                        </li>
                    </ul>
                </subsection>
            </section>

            <section name="Terms Used in This Document">
                <table>
                    <tr><th>Term</th><th>Explanation</th>
                    </tr><tr><td>Signer</td><td>A Processable service performing signatures upon requests. This could be a ready made signer or a custom developed one.</td>
                    </tr><tr><td>Crypto Token (former Sign Token)</td><td>A Crypto Token is a name for the entity containing the private key and is responsible for its cryptographic operations. Every Processable have a Crypto Token that can be a PKCS12, Smart Card or HSM connection.</td>
                    </tr><tr><td>Extended Crypto Token</td><td>An enhanced Crypto Token with support for symmetric key operations.</td>
                    </tr><tr><td>PKCS11CryptoToken</td><td>A Crypto Token able to communicate with Hardware Security Modules through the standard PKCS11 interface.</td>
                    </tr><tr><td>TimedService (former Service)</td><td>A TimedService is a task that is run on a timely basis, performing maintenance tasks like changing active key or generate a report.</td>
                    </tr><tr><td>Worker</td><td>A common name for Processable (Signer or other type of service) and TimedService</td>
                    </tr><tr><td>Processable</td><td>A type of worker that is used to process requests, i.e. not a TimedService.</td>
                    </tr><tr><td>Worker Configuration</td><td>Each Worker can be configured with properties specific for that worker. There are two sets of worker configuration one "Active" that is used by the signer and one "current" which is the one configured by the administrator. The current configuration isn't used in production until the administrator issued the reload command. This makes it possible for the administrator to configure multiple properties and double-check them before they are actually used.</td>
                    </tr><tr><td>Global Configuration Store</td><td>Is a dynamic store used to define available Workers and their Crypto Tokens. But other data that needs to be read globally could be set there as well. The global configuration properties are activated immediately. There are two different scopes for the store data, Global Scope and Node Scope.</td>
                    </tr><tr><td>Global Scope</td><td>Data stored in the global configuration that can be read by all nodes in the cluster.</td>
                    </tr><tr><td>Node Scope</td><td>Data that is node specific and can only be read within the same node.</td>
                    </tr><tr><td>Worker Id</td><td>Unique identifier of a worker, an integer larger than 0</td>
                    </tr><tr><td>Worker Name</td><td>A name used as a human readable synonym for a Worker Id</td>
                    </tr><tr><td>Validation Service </td><td>A Processable that checks if a certificate is valid or not. Have a Default Validation Service implementation that should work in most cases.<br/>A Validation Service should have one or more Validators configured.</td>
                    </tr><tr><td>Group Key Service</td><td>A Processable that can be used to manage, generate and distribute group keys to a set of clients. The service support four types of calls, fetch group key (used by clients), pre-generate group keys, switch encryption key (key used to safely store the group keys in database) and remove group keys.  There exists a Default Group Key Service that should satisfy most use cases.</td>
                    </tr><tr><td>Certificate Validator (former Validator)</td><td>A Certificate Validator is responsible for checking the status of one or more issuer's certificates. This could be as an OCSP client or a CRL checker or just looking up the status in a database.</td>
                    </tr><tr><td>Document Validator</td><td>A Document Validator is validating a signed document by checking its signature and corresponding certificate(s) and returns the validation result.</td>
                    </tr><tr><td>Authorizer</td><td>An interface that enables developers to integrate the authorization parts with existing authorization systems of who is authorized to perform requests to a Processable.</td>
                    </tr><tr><td>Time Stamp Signer</td><td>A Signer that can be used to set up a Timestamp Authority according to RFC 3161. </td>
                    </tr><tr><td>MRTD Signer</td><td>A Signer that performs signatures of MRTD (Machine Readable Travel Documents, i.e. Electronic Passports) blobs.</td>
                    </tr><tr><td>MRTD SOD Signer</td><td>A Signer that creates the complete security object (SOd) for a MRTD (Machine Readable Travel Document, i.e. Electronic Passports) by signing the data groups.</td>
                    </tr><tr><td>PDF Signer</td><td>A Signer that attaches an electronic signature signature to a PDF document.</td>
                    </tr><tr><td>XML Signer</td><td>A Signer that puts in an enveloped signature in XML documents (XMLDSig)</td>
                    </tr><tr><td>XML Validator</td><td>A Document Validator that validates signed XML documents (XMLDSig)</td>
                    </tr><tr><td>ODF Signer</td><td>A Signer that attaches an electronic signature to an ODF document. ODF Signer is tested with documents produced by <a href="http://www.openoffice.org">OpenOffice.org v 3.1.0</a></td>
                    </tr><tr><td>ODF (Open Document Format) Document</td><td>XML-based file format for representing electronic documents such as spreadsheets, charts, presentations and word processing documents. <a href="http://en.wikipedia.org/wiki/OpenDocument">more...</a></td>
                    </tr><tr><td>OOXML (Office Open XML) Document</td><td>XML-based file format  for representing spreadsheets, charts, presentations and word processing documents. <a href="http://en.wikipedia.org/wiki/Office_Open_XML">more...</a></td>
                    </tr><tr><td>OOXML Signer</td><td>A Signer that attaches an electronic signature to an OOXML document.</td>
                    </tr>
                    <tr>
                        <td>Archiver</td>
                        <td>
Implementation handling archiving of a worker's response and/or request by storing it in a database or similar.
                        </td>
                    </tr>
                </table>
            </section>

            <section name="Overall Architecture">
                    <p>
The SignServer is a framework designed to perform different kind of cryptographic operations for different applications.
                    </p>
                    <p>
Since the 3.0 version there are three kind of processable services. Signers (used to sign or in other way  process requested data). Validation Services used to verify the validity of a certificate against a set of backed issuers. The validation service can be used to simply the integration of PKIs into existing applications. The the third processable service is a group key service framework used to manage and to distribute group keys for different applications, these keys can be both symmetric and asymmetric. In addition to processable services there also exists another concept called Timed Service (called just 'service' in 2.0 edition) which are plug-ins run at defined intervals performing maintenance or reporting routines.
                    </p>
                    <p>
The main way of communicating with the SignServer is through HTTP (web server) interface. There is also a web services (SOAP WS) interface available but that uses a special binary format for encoding the requests and responses.
                    </p>
                    <p>
For an overview of the different concepts in the SignServer see illustration 1. The base component is called Worker which is assigned an id, optionally a name and a configuration. A sub component is a Processable which receives and processes requests. A Processable (optionally) have access to a cryptographic token (CryptoToken) in charge of managing the keys of a Processable. A CryptoToken can be either software or hardware based.
                    </p>
                    <p>
The applications i administrated through a command-line interface, where the properties and access control can be configured.
                    </p>
                    <p>
One SignServer can have multiple services for different purposes.
                    </p>

                    <p>
                        <a href="../docs/SignServer_Manual_3_0_odt_18c42972.png"><img src="../docs/SignServer_Manual_3_0_odt_18c42972.png" align="middle" border="0" width="493" height="252" alt="SignServer components"/></a><br/>
                        Illustration 1: Components in the SignServer project
                    </p>
            </section>

        </chapter>

        <chapter name="Installation Guide" shortname="installguide">

            <section name="Server installation">
                <subsection name="1. Check prerequisites">
                    <p>
Make sure all required softwares are installed:
                    </p>
                    <ul>
                        <li>Java 6: Oracle JDK 6 Update 10 or later* or OpenJDK 6**</li>
                        <li>Application server: JBoss 5.1.0.GA*** or GlassFish Server Open Source Edition 2.1.1</li>
                        <li>Database: HypersonicSQL (bundled with JBoss), MySQL 5.1, Oracle Database 10/11g or without****</li>
                        <li>Build tool: Apache Ant 1.8.0 or later</li>
                    </ul>
                    <p>
* When using Oracle JDK you must install the 'Unlimited Strength Jurisdiction Policy Files' for JDK for the parts of SignServer that  makes use of strong crypto to work. The policy files can be found at the same place as the JDK download at Oracle. Further information on this can be found in the Oracle documentation on the JCE. <br/>
** The ODFSigner has issues with OpenJDK. Please see <a href="https://jira.primekey.se/browse/DSS-168">DSS-168</a> for a workaround.<br/>
*** JBoss 5.1.0.GA is available in two different versions (standard and JDK6) which differs in web services stacks. The one called JBoss 5.1.0.GA-JDK6 should be used.
**** See <a href="complete.en.html#SignServer%20without%20Database">SignServer without Database</a>.
                    </p>
                </subsection>

                <subsection name="2. Unpack SignServer">
                    <p>
Download and unzip the
<a href="http://sourceforge.net/projects/signserver/files/signserver/">latest
SignServer release</a> archive from SourceForge or for the absolutely latest
unstable version checkout from the Subversion (SVN)
<a href="http://sourceforge.net/projects/signserver/develop">repository</a>.
                    </p>
                </subsection>

                <subsection name="3. Set environment variables">
                    <subsubsection name="APPSRV_HOME">
                        <p>
Set APPSRV_HOME to point to your application server installation (<code>/opt/jboss</code> could be a symbolic link).
                        </p>
                        <source>
export APPSRV_HOME=/opt/jboss
                        </source>
                    </subsubsection>
                    <subsubsection name="ANT_OPTS">
                        <p>
Set ANT_OPTS to give Ant more memory for building SignServer.
                        </p>
                        <source>
export ANT_OPTS="-Xmx512m -XX:MaxPermSize=128m"
                        </source>
                    </subsubsection>
                    <subsubsection name="SIGNSERVER_HOME">
                        <p>
Set SIGNSERVER_HOME to point to your SignServer installation.
                        </p>
                        <source>
export SIGNSERVER_HOME=/opt/signserver
                        </source>
                    </subsubsection>
                    <subsubsection name="SIGNSERVER_NODEID">
                        <p>
Set SIGNSERVER_NODEID to an unique ID for the server.
                        </p>
                        <source>
export SIGNSERVER_NODEID=node1
                        </source>
                    </subsubsection>
                </subsection>

                <subsection name="4. Setup database">
                    <p>
Skip this section and instead follow the instructions in 
<a href="complete.en.html#SignServer%20without%20Database">SignServer without Database</a> if
you decide to run SignServer without a database management system.
                    </p>
                    <p>
Create a database and user for SignServer. The application server will try to
create tables during startup of SignServer but if the database user does not
have table create permissions or if you run on GlassFish the tables must be
created manually. See doc/sql-scripts/create-tables-signserver33-*.sql.
                    </p>
                    <p>
Copy the driver for your database to the application server lib folder.
                    </p>
                    <p>
For GlassFish also configure a connection pool and JNDI resource:
                    </p>
                    <ol>
                        <li>Go to the Admin Console: http://localhost:4848</li>
                        <li>Click on Resources -&gt; JDBC -&gt; Connection Pools</li>
                        <li>Add a new Pool. For instance: Name: MySQLPool</li>
                        <li>
                            Fill in:<br/>
                            databaseName: signserver<br/>
                            password: signserver<br/>
                            portNumber 3306<br/>
                            serverName: localhost<br/>
                            user: signserver
                        </li>
                        <li>Click Ping to test</li>
                        <li>Click on Resources -&gt; JDBC -&gt; JDBC Resources</li>
                        <li>
                             Add new:<br/>
                             JNDI Name: jdbc/SignServerDS<br/>
                             Pool Name: MySQLPool
                         </li>
                        <ul></ul>
                    </ol>
                </subsection>

                <subsection name="5. Configure web server keystores">
                    <p>
For JBoss if you are going to protect the HTTP communication with SSL, you need
a JKS SSL server keystore. Rename the web server keystore to tomcat.jks and put
it in a 'p12' subdirectory. Place a keystore called truststore.jks in the 'p12' directory
containing the trusted root certificate(s).
					</p>
                    <p>
For GlassFish enable client authentication for http-listener-2 and manually
update the keystores with the right certificates.
                    </p>
                </subsection>

                <subsection name="6. Configure application server">
                    <subsubsection name="Fix web service problem in JBoss">
                        <p>
Edit jboss-beans.xml to force the endpoint URL to be generated based on the WSDL
request by commenting out the line:
                        </p>
<pre>
    &lt;property name="webServiceHost"&gt;${jboss.bind.address}&lt;/property&gt;
</pre>
                        <p>
For JBoss 5.1.0.GA the file is available under: server/default/deployers/jbossws.deployer/META-INF/
                        </p>
                    </subsubsection>
                    <subsubsection name="Fix JBoss 5 bug with Oracle JDK">
                        <p>
If you are using Oracle's JDK and JBoss 5.1.x you need to copy
SIGNSERVER_HOME/lib/ext/1.6/bc*.jar to JBOSS_HOME/server/default/lib/. Remember this
when it's time for upgrades! This is a bug tracked by JBoss as JBAS-7882.
                        </p>
                    </subsubsection>
                </subsection>


                <subsection name="7. Configure build">
                    <p>
Copy conf/signserver_build.properties.sample to conf/signserver_build.properties and open
it for editing in your favorite text editor.
                    </p>
                    <source>
cp conf/signserver_build.properties.sample conf/signserver_build.properties
                    </source>

                    <subsubsection name="Application server configuration">
                        <p>
Set appserver.type to the application server (jboss or glassfish).
                        </p>
                        <source>
appserver.type=jboss
                        </source>
                    </subsubsection>

                    <subsubsection name="Web GUI configuration">
                        <p>
Uncomment j2ee.web-nohttps=true if SignServer should be used to configure the
keystore in JBoss.
                        </p>
                        <source>
#j2ee.web-nohttps=true
                        </source>
                        <p>
For GlassFish change httpserver.privhttps to a port configured with HTTPS and
client authentication.
                        </p>
                        <source>
httpserver.privhttps=8181
                        </source>
                    </subsubsection>

                    <subsubsection name="Database configuration">
                        <p>
For GlassFish make sure the datasource.jndi-name and datasource.jndi-name-prefix
matches the resource configured in the admin console.
                        </p>
                        <source>
datasource.jndi-name=SignServerDS
datasource.jndi-name-prefix=jdbc/
                        </source>
                        <p>
Select database management system
                        </p>
                        <source>
database.name=mysql
                        </source>

                        <p>
For JBoss set the database connection URL, database driver and username and
password.
                        </p>
                        <source>
database.url=jdbc:mysql://127.0.0.1:3306/signserver
database.driver=com.mysql.jdbc.Driver
database.username=signserver
database.password=signserver
                        </source>
                    </subsubsection>

                    <subsubsection name="Web Service Configuration">
                        <p>
Enable or disable the web services.
                        </p>
                        <source>
signserverws.enabled=true
genericws.enabled=true
validationws.enabled=true
adminws.enabled=true
clientws.enabled=true
                        </source>
                    </subsubsection>

                    <subsubsection name="Modules Configuration">
                        <p>
Enable all modules that should be built and choose if they should be included in the SignServer enterprise application archive (EAR). By setting includemodulesinbuild=true (default) all modules are built in. Otherwise for each module specify that it should be enabled and included:
                        </p>
                        <source>
module.xmlsigner.enabled=true
module.xmlsigner.include=true
...
                        </source>
                        <p>
For GlassFish to enable debug logging include the Log4j module.
                        </p>
                        <source>
module.log4j.enabled=true
module.log4j.include=true
                        </source>
                    </subsubsection>

                </subsection>

                <subsection name="8. Build and deploy SignServer">
                    <p>
Run "ant deploy" to build SignServer and deploy it to the selected application
server. If the configuration changed since the last build run the clean target
first.
                    </p>
                    <source>
bin/ant clean build deploy
                    </source>
                    <p>
Start the application server and verify that SignServer was deployed and
database tables were created. 
                    </p>
				</subsection>
				<subsection name="9. Accessing SignServer">
					<p>
After startup a few different user interfaces are available.	
					</p>
					<subsubsection name="Command Line Interface">
                    <source>
bin/signserver getstatus brief all
Assuming JBoss JNDI provider...
===========================================
Executing Command on host : localhost
===========================================


Current version of server is : SignServer 3.3.0alpha0
                    </source>
					</subsubsection>
					<subsubsection name="Graphical User Interface">
						<source>
bin/signserver-gui	
						</source>
					</subsubsection>
					<subsubsection name="Web Interface">
					<p>
Point your web browser to <a href="http://localhost:8080/signserver">http://localhost:8080/signserver</a> for demo web pages and local documentation.
					</p>
					</subsubsection>
                </subsection>
            </section>

            <section name="Signer setup">
                <p>
After server installation the different signers can be setup using the
SignServer CLI.
                </p>
                <subsection name="Loading signers">
                    <p>
Signers (and other workers) can be loaded by setting properties using "setproperty" or "setproperties" etc.
                    </p>
                    <subsubsection name="setproperties">
                        <p>
The "setproperties" command loads all the properties from a property file that
can define one or many signers. The code for the signers needs to be deployed
to the application server together with SignServer either by setting
includemodulesinbuild=true to include all modules or by setting individual
module.MODULENAME.include=true properties in signserver_build.properties.
                        </p>
                        <source>
bin/signserver setproperties doc/sample-configs/CONFIGURATION.PROPERTIES
                        </source>
                    </subsubsection>
                    <p>
After adding or changing a property for a worker (by
any of the "setpropery" or "setproperties" commands) the configuration needs be
applied by issuing the reload command with the ID of the worker.
                    </p>
                    <source>
bin/signserver reload 4711
                    </source>
                </subsection>

                <subsection name="Quick start demo Timestamp signer">
                    <p>
This is a quick start guide to quickly get you setup with a demo Time Stamp service (TSA according to RFC3161). It will let you quickly get a feeling how the structure of the SignServer works, so you can move on to more advanced features described in the manual.
                    </p>

                    <ol>
                        <li>
Make sure the tsa module is built in by setting module.tsa.enabled=true and
module.tsa.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the Timestamp demo configuration and notice the generated worker ID (in this
example 1):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_timestamp_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 1</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                        <li>
Run the test client to see that everything is up:<br/>
<code>$ bin/signclient timestamp http://localhost:8080/signserver/process?workerName=TimeStampSigner</code>
<br/>The message "TimeStampRequest validated" should appear once a second. Also
check JBOSS_HOME/server/default/log/server.log or
GLASSFISH_HOME/domains/domain1/logs/server.log that successful messages appear.
                        </li>
                    </ol>
                </subsection>

                <subsection name="Quick start demo PDF signer">
                    <p>
To install the PDF signer you can issue the following commands (either instead of the TSA or in addition to the TSA).
                    </p>
                    <ol>
                        <li>
Make sure the pdfsigner module is built in by setting module.pdfsigner.enabled=true and
module.pdfsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the PDF signer demo configuration and notice the generated worker ID (in this
example 2):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_pdfsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 2</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
</ol>
<p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/pdfsign.jsp">http://localhost:8080/signserver/demo/pdfsign.jsp</a> to get PDF documents signed.
</p>
</subsection>

                <subsection name="Quick start demo OOXML signer">
                    <p>
To install the OOXML signer you can issue the following commands.
                    </p>
                    <ol>
                        <li>
Make sure the ooxmlsigner module is built in by setting module.ooxmlsigner.enabled=true and
module.ooxmlsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the OOXML signer demo configuration and notice the generated worker ID (in this
example 3):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_ooxmlsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 3</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                    </ol>
<p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/ooxmlsign.jsp">http://localhost:8080/signserver/demo/ooxmlsign.jsp</a> to get any Office Open XML documents signed (ex: MS Office 2007 Word document, Excel document, Power Point presentation...).
</p>
</subsection>

                <subsection name="Quick start demo ODF signer">
                    <p>
To install the ODF signer you can issue the following commands.
                    </p>
                    <ol>
                        <li>
Make sure the odfsigner module is built in by setting module.odfsigner.enabled=true and
module.odfsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the ODF signer demo configuration and notice the generated worker ID (in this
example 4):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_odfsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 4</code>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                    </ol>
                    <p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/odfsign.jsp">http://localhost:8080/signserver/demo/odfsigner.jsp</a> to get any Open Document Format documents signed (ex: documents produced by OpenOffice.org or LibreOffice).
                    </p>
                </subsection>


                <subsection name="Quick start demo XML signer">
                    <p>
To install the demo XML signer you can issue the following commands.
                    </p>
                    <ol>
                        <li>
Make sure the xmlsigner module is built in by setting module.xmlsigner.enabled=true and
module.xmlsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the XML signer demo configuration and notice the generated worker ID (in this
example 5):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_xmlsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code># bin/signserver reload 5</code>
<br/>
                        </li>
                        <li>
You can check the status and configuration with:<br/>
<code>$ bin/signserver getstatus complete all</code>
                        </li>
                    </ol>
                    <p>
You can now, with your web browser, access the URL <a href="http://localhost:8080/signserver/demo/xmlsign.jsp">http://localhost:8080/signserver/demo/xmlsign.jsp</a> to get XML documents signed.
                    </p>
                </subsection>

                <subsection name="Quick start demo XML validator">
                    <p>
An XML validator validates the signature of an XML document. It uses a
certificate validation service worker for validating the certificate so
that worker has to be configured first.
                    </p>
                    <p>
To install a certificate validation service worker issue the following commands:
                    </p>
                    <ol>
                        <li>
Load the configuration and notice the worker ID (in this example: 6):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_validator_dummy_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 6</code>
<br/>
                        </li>
                        <li>
The status of the Worker can now be viewed with:<br/>
<code>$ bin/signserver getstatus complete CertValidationWorker</code>
<br/>
                        </li>
                    </ol>
                    <p>
Then to install the XML validator you can issue the following commands:
                    </p>
                    <ol>
                        <li>
Make sure the xmlvalidator module is built in by setting module.xmlvalidator.enabled=true and
module.xmlvalidator.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the XML validator demo configuration and notice the generated worker ID (in this
example 7):
<br/>$ bin/signserver setproperties doc/sample-configs/qs_xmlvalidator_configuration.properties
                        </li>
                    <li>
Verify the configuration with (notice that VALIDATIONSERVICEWORKER is set to "CertValidationWorker"):<br/>
<code>$ bin/signserver getconfig 7</code>
<br/>
                    </li>
                    <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 7</code>
<br/>
                    </li>
                    <li>
The status of the Validator can now be viewed with:<br/>
<code>$ bin/signserver getstatus complete DemoXMLValidator</code>
<br/>
                    </li>
                    </ol>
                    <p>
Now <a href="integration.html">the SignServer APIs</a> can be used to request XML documents to be validated by the DemoXMLValidator worker.
                    </p>
                </subsection>

                <subsection name="Quick start demo MRTD SOD signer">
                    <p>
The MRTD SOD signer takes as input data group hashes and creates a signed SO(d). This means that the signserver will function
as a Document Signer for ePassports.</p>
                    <p>
To install the MRTD SOD signer you can issue the following commands:
                    </p>
                    <ol>
                        <li>
Make sure the mrtdsodsigner module is built in by setting module.mrtdsodsigner.enabled=true and
module.mrtdsodsigner.include=true in signserver_build.properties before building and
deploying SignServer. Alternativly, set includemodulesinbuild=true to have all
modules built in.
                        </li>
                        <li>
Load the MRTD SOD signer demo configuration and notice the generated worker ID (in this
example 8):<br/>
<code>$ bin/signserver setproperties doc/sample-configs/qs_mrtdsodsigner_configuration.properties</code>
                        </li>
                        <li>
Activate the configuration with:<br/>
<code>$ bin/signserver reload 8</code><br/>
                        </li>
                        <li>
The status of the signer can now be viewed with:<br/>
<code>$ bin/signserver getstatus complete mrtdsodsigner</code><br/>
                        </li>
                    </ol>
                    <p>
Now <a href="integration.html">the SignServer APIs</a> can be used to send MRTD SOD sign requests the MRTDSODSigner.
<br/>
Also you can use the HTML page <a href="http://localhost:8080/signserver/demo/mrtdsodsign.jsp">http://localhost:8080/signserver/demo/mrtdsodsign.jsp</a> to enter requests and get the SOd back.
This HTML form also functions as a sample to show how you can make HTTP requests from the personalisation system to the Document Signer.
                    </p>
                    <subsubsection name="Production configuration with HSM">
                        <p>
To install a production signer using an HSM instead of the demo signer you can
edit doc/sample-config/qs_mrtdsodsigner_configuration.properties and change from
SoftCryptoToken to PKCS11CryptoToken and comment all properties under
SoftCryptoToken properties and instead fill in all properties under
PKCS11CryptoToken properties and then run:
<br/>(note after changing properties in the file it needs to be loaded again
with setproperties)
                        </p>
                        <p>
Before starting with an HSM installation you should read the about the
<a href="plugins.html#PKCS11CryptoToken">PKCS11CryptoToken</a> in the plugins
section of the manual.
                        </p>
<source>
bin/signserver setproperties doc/sample-config/qs_mrtdsodsigner_configuration.properties
bin/signserver getconfig 9
bin/signserver reload 9
bin/signserver generatecertreq 9 "C=SE,CN=MRTD SOD Signer" SHA256WithRSA mrtdsodsigner.req
</source>
                        <p>
Where 9 is the signerId that you got when running the 'setproperties' command.<br/>
This will create a certificate request that you can get signed by your CA. When you have received the response you can import it and the CA certficate.
If you have the returned signer certificate as cert.pem and the CA certificate as cacert.pem, then:
                        </p>
<source>
cat cert.pem cacert.pem &gt; certchain.pem
bin/signserver uploadsignercertificate 9 glob cert.pem
bin/signserver uploadsignercertificatechain 9 glob certchain.pem
bin/signserver reload 9
</source>
                        <p>
Hint: you can use EJBCA to create keys on a PKCS#11 HSM using clientToolBox.<br/>
ejbcaClientToolBox.sh PKCS11HSMKeyTool generate /opt/ETcpsdk/lib/linux-x86_64/libcryptoki.so 2048 DSSignKey 5
                        </p>
                    </subsubsection>
            </subsection>

            </section>
              
            <section name="Upgrade">
                <p>
See SIGNSERVER_HOME/doc/RELEASE_NOTES.txt and UPGRADE.txt for information about upgrading from an earlier version of SignServer. 
                </p>
            </section>

            <section name="Historic Installation Guides">
                <subsection name="Clustered SignServer 3.0 CentOS 4.4 Installation Guide">
                    <p>
Installation guide describing step-by-step how to setup a SignServer cluster on CentOS 4.4. Even if the document
is specific for this OS is should be quite easy to adopt it to other environments as well. It 
can be downloaded here either as <a href="../docs/SignServer_3_0_Installation_Guide.pdf">PDF</a> or viewed as
<a href="../docs/SignServer_3_0_Installation_Guide.html">HTML</a>
                    </p>
                </subsection>
                <subsection name="Clustered SignServer 2.0 CentOS 4.4 Installation Guide">
                    <p>
Version 2.0 of the same documentation.<a href="../docs/SignServer_2_0_Installation_Guide.pdf">PDF</a> <a href="../docs/SignServer_2_0_Installation_Guide.html">HTML</a>
                    </p>
                </subsection>
            </section>
        </chapter>

        <chapter name="Usage Guide" shortname="usageguide">
            <section name="Introduction">
                <p>   
                </p>
            </section>

            <section name="Configuration/Administration">
                <p>
The SignServer administration command line interface (Admin CLI) is started
using bin/signserver (or bin/signserver.cmd).
                </p>
                <p>
Every worker is identified by an ID and an optional name that can be used in all
the CLI commands.
                </p>
                <p>
It is possible to do configuration of a worker while it's in production. All
configuration commands are cached until a reload command is issued and the
configuration becomes active.
                </p>
                <p>
There is a special property file for the cli interface called signserver_cli.properties defining which nodes that exists in the cluster. The properties are:
                </p>
                <p>
<b>hostname.masternode</b> = Should only contain one of the nodes, specified as the default master node. Used by operations dealing with the database and where not all nodes in the cluster needs to be contacted. It is possible to override this setting in the CLI by using the -host &lt;host name&gt; parameter.
                </p>
                <p>
<b>hostname.allnodes</b> = Should contain all the nodes in the cluster, separated by a ';'. Mainly used by the commands getStatus, activateCryptoToken and deactivateCryptoToken.
                </p>
                <p>
Its possible to customize the CLI with your own code. How to do this is described in the development section.
                </p>
                <subsection name="Administration CLI">
                    <subsubsection name="General Commands">
                        <p>
<b>getstatus:</b>
Returns the status of the given worker, it says if its crypto token is active or not and the loaded 'active' configuration. It is possible to get a <i>brief</i> summary or a <i>complete</i> listing for one worker or all configured workers. If all workers are displayed will also all the global configuration parameters be displayed.
                        </p>
                        <p>
<b>getconfig:</b>
Returns the current worker or global configuration depending on options.
                        </p>
                        <p>
For worker configuration observe that this configuration might not have been activated yet, not until a <i>reload</i> command is issued.
                        </p>
                        <p>
<b>setproperty:</b>
Sets a custom property used by the worker or crypto token, see reference for the given Worker and CryptoToken for available properties.
                        </p>
                        <p>
<b>setproperties:</b>
Command used to batch a set of properties, both for the global and worker configuration.
It can be used to configure a Signer in a test environment, dump all the properties and upload it into production.
                        </p>
                        <p>
It reads all the configuration properties form a property file and depending on the contents of the key it sets the given property. All properties will be set  according to the following defined rule set.
                        </p>
                        <table>
                            <tr>
                                <th>Rule</th>
                                <th>Comment</th>
                            </tr>
                            <tr>
                                <td>
Properties starting with id&lt;num&gt;.
                                </td>
                                <td>
Will set the property to the value of the given id to the worker with the given id.
                                </td>
                            </tr>
                            <tr>
                                <td>
Properties starting with name&lt;name&gt;.
                                </td>
                                <td>
Will set the property to a worker with the given name. (If the name doesn't exists a unique id will be generated and assigned).
                                </td>
                            </tr>
                            <tr>
                                <td>
Property keys containing GENID&lt;NUM&gt;, example WORKERGENID1 or GLOB. WORKERGENID1
                                </td>
                                <td>
The SignServer will find a free unique id and assign substitute all GENID&lt;num&gt; with this id.
                                </td>
                            </tr>
                            <tr>
                                <td>
Properties starting with glob.
                                </td>
                                <td>
Will set a global property with global scope.
                                </td>
                            </tr>
                            <tr>
                                <td>
Properties starting with node.
                                </td>
                                <td>
Will set a global property with node scope.
                                </td>
                           </tr>
                            <tr>
                                <td>
Properties starting with -&lt;other prefix&gt;&lt;value&gt;
                                </td>
                                <td>
Will remove the property, either worker or global.
                                </td>
                            </tr>
                        </table>
                        <p>
See the directory 'sample-configs' for examples.
                        </p>
                        <p>
<b>removeproperty:</b>
Removes a configured property
                        </p>
                        <p>
<b>dumpproperties:</b>
This tool will dump all configured properties for one or all workers in the system into a property file. If the configuration for one worker is dumped it can be used to transfer the configuration from one installation to another. If all configurations is dumped, it can be used as a backup tool.
                        </p>
                        <p>
<b>uploadsignercertificate:</b>
Used to upload the certificate when the worker only needs the actual signing certificate and not the entire chain.
                        </p>
                        <p>
<b>uploadsignercertificatechain:</b>
Used when uploading a complete certificate chain to the worker. Which command that is supposed to be used is depending on the worker and crypto token used.
                        </p>
                        <p>
<b>generatecertreq:</b>
Used to generate a certificate request for a worker to be signed by a certificate authority. It takes
distinguished name and signature algorithm as parameters and writes the request in PEM format to
file.
                        </p>
                        <p>
<b>activatecryptotoken:</b>
Used to activate crypto tokens. Authentication code is usually the PIN used to unlock the keys on the HSM. Not used if the token is set to auto-activation.
                        </p>
                        <p>
<b>deactivatecryptotoken:</b>
Brings a crypto token off-line. Not used if token is set to auto-activation.
                        </p>
                    </subsubsection>

                    <subsubsection name="SignServer Specific Commands">
                        <p><b>Authorization Related</b></p>
                        <p>
These commands are used to configure the internal client certificate authorization when it is turned on. It controls which clients that is authorized to request a processable worker.
                        </p>
                        <p>
<b>addauthorizedclient:</b>
Adds a client certificate to a processable workers list of acceptable clients using this worker. Specify
certificate serial number in hex and the Issuer DN of the client certificate.
                        </p>
                        <p>
<b>removeauthorizedclient:</b>
Removes added client certificate entries.
                        </p>
                        <p>
<b>listauthorizedclients:</b>
Displays the current list of acceptable clients.
                        </p>

                        <p><b>Database Related</b></p>
                        <p>
<b>resync:</b>
                        </p>
                        <p>
The 'resync' command is used after a SignServer had a complete database failure. When this happens  will the Global Configuration become in 'Off-line' mode and it's not possible for the nodes to communicate internally and the Global Configurations will not be in sync any more. After the database is up again can this command be sent to the node that have the most valid Global Configuration and write it to the database. After this will the Global Configuration be in 'On-line' mode again.
                        </p>

                        <p><b>Archive Related</b></p>
                        <p>
This commands can be used for processable workers that have archiving turned on. They 
are used to find specific archived responses. It's up to the implementation of the 
worker if it supports archiving or not and it is up to the chosen Archiver if it 
archives the data in way that it can be queried using this commands. For Archivers 
other than the default "OldDatabaseArchiver" and Base64DatabaseArchiver querying 
might have to be done directly in a database, filesystem or by some custom 
application.
                        </p>
                        <p>
<b>archive findfromarchiveid:</b>
Command used to extract archived data from database identified by the archive Id.
                        </p>
                        <p>
The Id depends on the worker, in case of the TSA is the TimeStampInfo serial number used.
The data is stored with the same file title as the archive id and with the file extension 
depending on the type of item, for instance ".request" or ".response".
                        </p>
                        <p>
<b>archive findfromrequestip:</b>
Used to extract all archived data requested from a specified IP address.
                        </p>
                        <p>
All data is stored as separate files with the archive id as file title and the file
extension depending on the type of item.
                        </p>
                        <p>
<b>archive findfromrequestcert:</b>
Used to extract all archived data requested from a client by specified it's certificates serial number and  issuer DN.
                        </p>
                        <p>
All data is stored as separate files with the archive id as file title and the file
extension depending on the type of item.
                        </p>

                        <p><b>Group Key Service Related</b></p>
                        <p>
These commands only applies for group key services.
                        </p>
                        <p>
<b>groupkeyservice pregeneratekeys:</b>
Command used to pregenerate a given number of group keys for a given group key service and stores them unassigned encrypted in the database. This commands can be used to let the cluster work on CPU insensitive key generation during low business hours.
                        </p>
                        <p>
<b>groupkeyservice removegroupkeys:</b>
Command used to remove group keys not used any more. A time range of when created, first used and last fetched can be used as criteria.
                        </p>
                        <p>
<b>groupkeyservice switchenckey:</b>
Command used manually switch the encryption key used to secure the group keys in database. Usually is the encryption key switched automatically but this command can be used to override this default behaviour.
                        </p>

                        <p><b>Administrators Related</b></p>
                        <p>
<b>wsadmins -list:</b>
                        </p>
                        <p>
Lists administrator certificates (certificate serial number and issuer DN) for
administrators authorized to use the Admin Web Service interface to administrate
SignServer.
                        </p>
                        <p>
<b>wsadmins -add:</b>
                        </p>
                        <p>
Authorizes an administrator to use the Admin Web Service interface by
certificate serialnumber and issuer DN.
                        </p>
                        <p>
<b>wsadmins -remove:</b>
                        </p>
                        <p>
Removes an administrator from the list of authorized administrators.
                        </p>
                        <p>
<b>auditlog -query:</b>
                        </p>
                        <p>
Query the CESeCore audit log.
                        </p>
                    </subsubsection>
                </subsection>
                
                <subsection name="Database CLI">
                    <p>
The SignServer Database CLI uses Java Persistence API (JPA) to connect to the 
SignServer database. The CLI is configured by the dbcli.* properties in 
signserver_cli.properties.
                    </p>
                    <p>
The CLI needs to have the JDBC driver of the selected database available on the 
classpath. This can be achieved by setting the OPTIONAL_CLASSPATH environment 
variable when calling the bin/signserver-db script or by putting the JAR under
lib/ext/jdbc/ and calling it jdbc.jar. The last method is required to be able 
to run the JUnit tests. 
                    </p>
                    <p>
Sample usage:
                    </p>
                    <source>
OPTIONAL_CLASSPATH=/usr/share/java/mysql-connector-java.jar bin/signserver-db audit verifylog
                    </source>
                    <subsubsection name="Verify Auditlog Command">
                        <p>
The command can be run to verify the signature of every entry in the auditlog 
as well as checking the sequence number in order to make sure that it does not 
contain any gaps.
                        </p>
                        <p>
The keys used to verify the log are configured in conf/databaseprotection.properties.
                        </p>
                        <p>
Sample output:
                        </p>
                        <source>
2013-02-08 21:26:13,067 INFO  [PKCS11CryptoToken] Activated Crypto Token with id 300.
2013-02-08 21:26:13,203 INFO  [VerifyLogCommand] Progress: node=0 rowCount=63
2013-02-08 21:26:13,685 INFO  [VerifyLogCommand] Progress: node=1 rowCount=701
2013-02-08 21:26:13,690 INFO  [VerifyLogCommand] Audit log validation completed in 1 seconds. 701 rows found. Errors: 0 Warnings: 0
2013-02-08 21:26:13,690 INFO  [VerifyLogCommand] Verification finished with success
                        </source>
                    </subsubsection>
                </subsection>

                <subsection name="Administration GUI">
                    <p>
As a complement to the command line interface there is also a graphical user
interface for managing some of the most basic administrative tasks.
                    </p>
                    <p>
The SignServer AdminGUI can be build by running "ant admingui" and then started 
using the script bin/admingui.sh. By default it tries to connect to a locally
running SignServer instance using EJB calls. If that fails or if the command
line option "-ws" is specified a connection dialog for connecting using web
services is displayed instead.
                    </p>
                    <subsubsection name="Connect to SignServer dialog">
                        <p>
Specify URL to SignServer server as well as keystore and truststore for setting
up the HTTPS connection and then click the button <b>Connect</b>. By clicking
the button <b>Load defaults</b> the settings from the file
default_connect.properties is loaded. If the connection is successful the
current settings are stored to connect.properties and displayed the next time
the dialog is openned.
                        </p>
                        <p>
<b>Web Service URL</b>: Base URL to the SignServer server. Default: https://localhost:8443/signserver
                        </p>
                        <p>
<b>Truststore Type</b>: Type of the truststore. Should match the choosen
truststore file (if any). Options are: "Use keystore", JKS, PKCS12 or PEM. If
"Use keystore" is choosen the trusted certificates are instead taken from the
keystore and no truststore is used.
                        </p>
                        <p>
<b>Truststore file path</b>: Path to the truststore file (if any).
                        </p>
                        <p>
<b>Truststore password</b>: Password of the truststore file (if any).
                        </p>
                        <p>
<b>Keystore Type</b>: Type of the keystore. Should match the choosen keystore file
path. Options are: JKS, PKCS12 or PKCS11. If PKCS11 is choosen the keystore file
path should be the patch to the PKCS#11 shared library file.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window">
                        <p>
The SignServer Administration GUI main window consists of a menu bar, a toolbar,
the working area and at the bottom a status bar. The working area constists of a
left and right part where the left is a list of all configured workers and the
right shows details for the selected workers (if any).
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Menu bar">
                        <p>
<b> File -&gt; Exit</b>: Exits the SignServer Administration GUI
                        </p>
                        <p>
<b> Edit -&gt; Activate</b>: Activates the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; deactivate</b>: Deactivates the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Renew key...</b>: Opens the Renew key dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Test key...</b>: Opens the Test key dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Generate CSR...</b>: Opens the Generate CSR dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Install certificates...</b>: Opens the Install certificates dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Renew signer...</b>: Opens the Renew signer dialog for the selected worker(s).
                        </p>
                        <p>
<b> Edit -&gt; Global configuration...</b>: Opens the Global configuration window.
                        </p>
                        <p>
<b> Edit -&gt; Administrators...</b>: Opens the Administrators window.
                        </p>
                        <p>
<b> View -&gt; Refresh</b>: Refreshes the information about all workers.
                        </p>
                        <p>
<b> View -&gt; Status Summary...</b>: Switches to the Status Summary tab for the selected worker.
                        </p>
                        <p>
<b> View -&gt; Status Properties...</b>: Switches to the Status Properties tab for the selected worker.
                        </p>
                        <p>
<b> View -&gt; Configuration...</b>: Switches to the Configuration tab for the selected worker.
                        </p>
                        <p>
<b> View -&gt; Authorization...</b>: Switches to the Authorization tab for the selected worker.
                        </p>
                        <p>
<b> Help -&gt; About...</b>: Opens the about box doc.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Tool bar">
                        <p>
<b>Refresh</b>: Refreshes the information about all workers.
                        </p>
                        <p>
<b>Activate</b>: Activates the selected worker(s).
                        </p>
                        <p>
<b>Deactivate</b>: Deactivates the selected worker(s).
                        </p>
                        <p>
<b>Renew key...</b>: Opens the Renew key dialog for the selected worker(s).
                        </p>
                        <p>
<b>Test key...</b>: Opens the Test key dialog for the selected worker(s).
                        </p>
                        <p>
<b>Generate CSR...</b>: Opens the Generate CSR dialog for the selected worker(s).
                        </p>
                        <p>
<b>Install certificates...</b>: Opens the Install certificates dialog for the selected worker(s).
                        </p>
                        <p>
<b>Renew signer...</b>: Opens the Renew signer dialog for the selected worker(s).
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Status Summary Tab">
                        <p>
Displays the status summary for the selected worker in the same format as the
CLI command "signserver getstatus complete".
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Status Properties Tab">
                        <p>
Displays the status in properties format with the option of viewing details
for some properties such as for the certificates.
                        </p>
                        <p>
<b>Details...</b>: Selecting an property and clicking this button opens a dialog box
with more information for the property (if supported). Currently for certificates
this openns the Certificate details dialog.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Configuration Tab">
                        <p>
Lists all the selected worker's configuration properties and gives the ability
to add, remove or edit properties.
                        </p>
                        <p>
<b>Add...</b>: Adds a new property to the selected worker.
                        </p>
                        <p>
<b>Edit</b>: Edit the selected property.
                        </p>
                        <p>
<b>Remove</b>: Removes the selected property.
                        </p>
                    </subsubsection>

                    <subsubsection name="Main window: Authorization Tab">
                        <p>
Lists all the authorized client certificates for the selected worker. Notice 
that this only applies if the worker has the AUTHTYPE set to CLIENTCERT 
otherwise information about authorized clients might be taken from other sources.
                        </p>
                        <p>
<b>Add...</b>: Adds a new authorized client. If the option 
"Apply changes to all selected workers" is checked the client is added to all 
the currently selected workers.
                        </p>
                        <p>
<b>Edit...</b>: Edits the selected authorized client. If the option 
"Apply changes to all selected workers" is checked the client is modified in all 
the currently selected workers.
                        </p>
                        <p>
<b>Remove</b>: Removes the selected client. If the option
"Apply changes to all selected workers" is checked the client is modified in all
the currently selected workers.
                        </p>
                    </subsubsection>
                    
                    <subsubsection name="Main window: Audit log">
                        <p>
In the "Audit log" tab controls for querying and filter the audit log exists.
                        </p>
                        <ul>
<li><b>Current conditions</b>: Lists query conditions used to filter the search results.</li>
<li><b>Add</b>: Opens a dialog box for adding query conditions.</li>
<li><b>Remove</b>: Removes the selected query condition.</li>
<li><b>First</b>: Go to the first search results page.</li>
<li><b>Previous</b>: Go to the previous search results page.</li>
<li><b>Reload</b>: Loads or reloads the search result according the the current 
search condition(s), index and the selected number of entries per page.</li>
<li><b>Next</b>: Go to the next search results page.</li>
<li><b>Displaying results</b>: Displays the first row index and the last in the current result.</li>
<li><b>Entries per page:</b>: The maximum number of rows to display in one page.</li>
                        </ul>
                        <p>
Double clicking or pressing the Enter key on a selected row opens a window 
showing details for the row.
                        </p>
                        <p>
If databaseprotection.enableverify is enabled at the server side the signature 
of each row displayed are verified. If the verification fails for any of the 
rows in a page, an error message is displayed. The error message contains 
information about the first row that failed.
                        </p>
                        
                    </subsubsection>

                    <subsubsection name="Renew key dialog">
                        <p>
Generates new keys for all the listed workers. For this to work all workers should
have the same password. Key algorithm, Key specification and New key alias must
be specified if it is not taken from the worker's configuration.
                        </p>
                    </subsubsection>

                    <subsubsection name="Test key dialog">
                        <p>
Test keys for all the listed workers. It is optional to either test the current
key or the next key (if any) or all the keys in the keystore. For this to work
all workers should have the same password. The results shows for each key the
key alias, SUCCESS and the public key hash if the test signing succeded.
                        </p>
                    </subsubsection>

                    <subsubsection name="Generate CSR dialog">
                        <p>
Generates certificate signing requests (CSR:s) in PKCS#10 format for all listed 
signers and either for the current key (Default key) or the next key. 
Signature algorithm, subject distingueshed name (DN) and Filename must be 
specified if not already taken from the worker's configuration. The format of 
the request could either be a Standard CSR file or a CSR wrapped in PKCS#7/CMS 
signed object created by a RequestSigner. The with the last option is that at 
the CA the signature of the request can be verified.
                        </p>
                    </subsubsection>

                    <subsubsection name="Install certificates">
                        <p>
Installs signer certificate and certificate chains for the listed workers and
if next key is choosen that key becomes the new default key.
                        </p>
                        <p>
<b>Signer certificate</b>: Browse for the signer certificate file in PEM format.
                        </p>
                        <p>
<b>Certificate chain</b>: Browse for the signer certificate chain file in PEM
format. The signer certificate is added to the chain if it is not already
included so normally this could just be the CA certificate.
                        </p>
                    </subsubsection>

                    <subsubsection name="Renew signer dialog">
                        <p>
Requests a Renewal worker to renew all the choosen and selected workers. The 
Renewal worker will generate a new key if there isn't already a next key available 
and then contact EJBCA using its web service interface to request a new certificate.
After recieving the new certificate it is installed and the next key becomes 
the current default key. Notice how the "Not valid after" date and possibly also
the Signings column changes and the Renewal checkbox gets unchecked after a
successfull renewal.
                        </p>
                    </subsubsection>

                    <subsubsection name="Global configuration dialog">
                        <p>
Lists all the global configuration properties and gives the ability to add,
remove or edit properties.
                        </p>
                    </subsubsection>

                    <subsubsection name="Administrators dialog">
                        <p>
Lists all the authorized WS administrators and gives the ability to add,
remove or edit authorized administrators.
                        </p>
                    </subsubsection>

                </subsection>

                <subsection name="Working with Workers">
                    <p>
In SignServer operations are performed by workers. There can be many workers 
and each worker has its own configuration. Each worker is identified by an unique 
ID. A worker can also be configured with a name by setting the property NAME. 
After the configuration has been activated (by issuing reload with the worker ID) 
that name can also be used to address the worker.
                    </p>
                    <subsubsection name="Configuring">
                        <p>
A worker is configured by setting properties for it. Specifically if the plugin
is built-in it is specified by setting the property CLASSPATH to the fully
qualified name of the class implementing the plugin.
                        </p>
                        <p>
The properties can be set manually using the setproperty command or by loading
them all at once from a configuration file using the setproperties command.
Sample configuration files are available in SIGNSERVER_HOME/sample-configs.
                        </p>
                        <p>
To setup a PDFSigner using the quick start configuration file issue the
following command:
                        </p>
                        <source>
bin/signserver setproperties sample-configs/qs_pdfsigner_configuration.properties
                        </source>
                        <p>
Notice the created workerId and use it when applying the configuration using the
reload command:
                        </p>
                        <source>
bin/signserver reload WORKER-ID
                        </source>
                    </subsubsection>
                <subsubsection name="Remove Workers">
                    <p>
                    You can list which workers you have with the command:
                    </p>
                    <source>
bin/signserver getstatus brief all                    
                    </source>
                    <p>
                    If will display for example:
                    </p>
                    <source>
===========================================
Executing Command on host : localhost
===========================================


Current version of server is : SignServer 3.3.0alpha0


Status of Signer with Id 1 is :
  SignToken Status : Offline
  Signings: 0
                    </source>
                    <p>
                    You can remove the worker with Id 1 with the command:                    
					</p>
                    <source>
bin/signserver removeworker 1
bin/signserver reload all                    
                    </source>
                </subsubsection>
            </subsection>
            </section>

            <section name="Making the SignServer highly-available">
                <p>
Here are some tips on configuration used to make the SignServer redundant. Usually is the SignServer set-up with three nodes (required minimum for MySQL cluster) where one node is a management node from were all deployment and administration is done and the other two services are service nodes processing the actual requests.
                </p>
                
                <subsection name="HTTP access requires a load balancer">
                    <p>
HTTP based workers like the TSA can be clustered using a load balancer accessing a health check servlet returning the state of the SignServer. The basic settings of the health check servlet can be configured in the build configuration file but more advanced settings are done in 'src/web/healthcheck/WEB-INF/web.xml'. With the default settings will the servlet return the text 'ALLOK' when accessing the URL http://localhost:8080/signserver/healthcheck/signserverhealth. If something is wrong with the sign server will an error message be sent back instead.
                    </p>
                    <p>
The health check servlet can also be used to monitor the SignServer by creating a script that monitors the URL periodically for error messages.
                    </p>
                    <p>
Tip, heartbeat with ldirectord is a good solution for a load balancer and works well with the SignServer. KeepAlived is another open source solution.
                    </p>
                    <p>
The Main WebService using the Java client API manages the HA parts itself and then isn't a load balancer necessary.
                    </p>
                </subsection>
                <subsection name="Setting up a MySQL Cluster">
                    <p>
The database backed of the SignServer can be made redundant using MySQL Cluster. Details on how to set-up the MySQL cluster can be found in the document <a href="../docs/SignServer_3_0_Installation_Guide.pdf">SignServer_3_0_Installation_Guide.pdf</a> that can be downloaded from <a href="http://www.signserver.org">www.signserver.org</a>.
More information about the MySQL Cluster can be found at
<a href="http://www.mysql.com/products/database/cluster/">http://www.mysql.com/products/database/cluster/</a>.
                    </p>
               </subsection>
               <subsection name="Healthcheck">
                   <subsubsection name="Setting up the Health check servlet">
                    <p>
In SignServer there exists a health check service that can be used for health monitoring. It is also useful for cluster, as it can be checked by load balancers to determine if a node should be active in the cluster (healthy) or taken out of the cluster (unhealthy).
                    </p>
                    <p>
The servlet is located at the URL: http://localhost:8080/signserver/healthcheck/signserverhealth and configured in signserver_build.properties.
                    </p>
                    <p>
The following configuration parameters may be set to configure authorization and what the service checks: 
                    </p>
                    <p>
<source>healthcheck.authorizedips</source> - A semicolon-delimited list of IP addresses authorized to access
the healthcheck servlet (defaults to <source>127.0.0.1</source>).
                    </p>
                    <p>
<source>healthcheck.minimumfreememory</source> - Number of megabytes of memory that must be free before removing     
the node out of the cluster (defaults to 1).
                    </p>
                    <p>
<source>healthcheck.checkdbstring</source> - The string that should be used to do 
a minimal check that the database is working. May differ between databases.
(defaults to <source>Select count(*) from signerconfigdata</source>, the property is not used when running without database).
                    </p>
                    <p>
<source>healthcheck.maintenancefile</source> - The path to a file containing the maintenance state, this file is a
standard Java property file and should have a property (by default named <source>DOWN_FOR_MAINTENANCE</source>").
If this property has the value <source>true</source>, none of the standard health checks will be performed, and instead
the result will be a string of the form <source>MAINT: DOWN_FOR_MAINTENANCE</source>.
If this property is not set (or an invalid file is given), the maintenance functionallity is disabled.
                    </p>
                    <p>
<source>healthcheck.maintenancepropertyname</source> - The property name to be used in the maintenance file. This will also
affect the error message returned when in maintenance mode (the part of the string after <source>MAINT: </source>
(defaults to <source>DOWN_FOR_MAINTENANCE</source>).
                    </p>
                </subsubsection>
                
                <subsubsection name="Available tests and responses">
                    <ul>
                        <li>
                            <p>
<b>No errors</b><br/>
If all tests passed the HTTP result code is "200 OK" and page contains only the text "ALLOK".
                            </p>
                        </li>
                        <li>
                            <p>
<b>Down for maintenance</b><br/>
If the down for maintenance file indicates that the server is down for maintenance an HTTP response code in 5xx range is returned with an error page containing "MAINT: " followed of the name of the maintenance property as configured. No further checks are performed.
                            </p>
                        </li>
                        <li>
                            <p>
<b>Database test</b><br/>
A test is performed that SignServer is able to query the database. When running without database a check is made that the configured directory is initialized correctly and is not empty. If anything failed one or more error messages are included in an error page returned with the HTTP response code in the 5xx range.
                            </p>
                        </li>
                        <li>
                            <p>
<b>Memory test</b><br/>
Checks the available free memory. If anything failed an error message is included in an error page returned with the HTTP response code in the 5xx range.
                            </p>
                        </li>
                        <li>
                            <p>
<b>Workers test</b><br/>
Each (non-disabled) worker is checked for a number of things. If anything failed one or more error messages are included in an error page returned with the HTTP response code in the 5xx range.
                            </p>
                            <ul>
                                <li><b>Token offline:</b> Workers having a crypto token can be reported as offline</li>
                                <li><b>Worker status and errors: </b> Each worker implementation can put different requirements on when it is status is considered to be offline.</li>
                                <li><b>Signer certificate:</b> Signers requiring a certificate are checked that they have a certificate matching the configured key-pair and that the certificate is valid according the certificate validity time and the configured minimum remaining validity time.</li>
                                <li><b>TimeStampSigner certificate missing EKU:</b> If a TimeStampSigner certificate does not include the required EKU its status is set to offline.</li>
                                <li><b>TimeStampSigner certificate not included in certificate chain</b> If a TimeStampSigner certificate chain property does not include the signer certificate its status is set to offline.</li>
                            </ul>
                        </li>
                        <li>
<b>Disabled workers</b><br/>
Workers that are disabled by having the worker property DISABLED=true are not considered in the Health check report.
                        </li>
                    </ul>
                </subsubsection>
               </subsection>
            </section>

            
            <!--<section name="Howtos">
                <p>
...
                </p>
            </section>-->
  
        </chapter>

        <chapter name="Integration" shortname="integration">
            <!--<p>
                TODO: Introduction
            </p>-->
            <section name="JavaDoc">
                    <p>
                            The JavaDoc for SignServer is available at SIGNSERVER_HOME/doc/api/index.html
                            after running "ant javadoc".
                    </p>
		</section>

        <section name="Client Web Service">
            <p>
The SignServer ClientWS interface can be used request signings from SignServer.
            </p>
            <p>
The WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/ClientWSService/ClientWS?wsdl and locally in the sources under modules/SignServer-Client-ClientWS/xml-resources/web-service-references/ClientWS/wsdl/localhost_8080/signserver/ClientWSService/ClientWS.wsdl.
            </p>
            <subsection name="Operations">
                <table>
                    <!-- processData -->
                    <tr>
                        <td>
                            <p>
                                <b>
processData
                                </b>
                            </p>
                        </td>
                        <td>
                            <p>
Generic operation for request signing of any binary (or character) data.
                            </p>
                            <p>
Parameters:
                                <ul>
                                    <li>
<b>worker</b> (string)<br/>
Name of worker in SignServer which should handle the request.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Optional additional request data. For instance the PDFSigner accepts the PDF password as a request data.
                                    </li>
                                    <li>
<b>data</b> (base64Binary)<br/>
The document/data to process.
                                    </li>
                                </ul>
                            </p>
                            <p>
Output:
                                <ul>
                                    <li>
<b>archiveId</b> (string)
                                        <br/>
Identifier for the request if archiving was used.
                                    </li>
                                    <li>
<b>data</b> (base64Binary)<br/>
The SOD binary.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Any optional additional response data.
                                    </li>
                                    <li>
<b>requestId</b> (integer)<br/>
Identifier for the request/response.
                                    </li>
                                    <li>
<b>signerCertificate</b> (base64Binary)<br/>
The signer certificate in binary format if available.
                                    </li>
                                </ul>
                            </p>
                            <p>
Faults:
                                <ul>
                                    <li>RequestFailedException</li>
                                    <li>InternalServerException</li>
                                </ul>
                            </p>
                        </td>
                    </tr>
                    
                    <!-- processSOD -->
                    <tr>
                        <td>
                            <p>
                                <b>
processSOD
                                </b>
                            </p>
                        </td>
                        <td>
                            <p>
Operation for requesting an SOD to be created and signed.<br/>
The ePassport production system calls this operation to get an SOD for the supplied data groups.
                            </p>
                            <p>
Parameters:
                                <ul>
                                    <li>
<b>worker</b> (string)<br/>
Name of worker in SignServer which should be used for constructing the SOD.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Optional additional request data. Not used.
                                    </li>
                                    <li>
<b>sodData</b> (a sodRequest structure)<br/>
The sodRequest should contain a sequence of datagroups (id 1-16 and their values),
optionally also the version of the LDS to use and the version of Unicode.
                                    </li>
                                </ul>
                            </p>
                            <p>
Output:
                                <ul>
                                    <li>
<b>archiveId</b> (string)
                                        <br/>
Identifier for the request if archiving was used.
                                    </li>
                                    <li>
<b>data</b> (base64Binary)<br/>
The SOD binary.
                                    </li>
                                    <li>
<b>metadata</b> (sequence of key-value pairs)<br/>
Any optional additional response data.
                                    </li>
                                    <li>
<b>requestId</b> (integer)<br/>
Identifier for the request/response.
                                    </li>
                                    <li>
<b>signerCertificate</b> (base64Binary)<br/>
The signer (DS) certificate in binary format if available.
                                    </li>
                                </ul>
                            </p>
                            <p>
Faults:
                                <ul>
                                    <li>RequestFailedException</li>
                                    <li>InternalServerException</li>
                                </ul>
                            </p>
                        </td>
                    </tr>
                    
                </table>
            </subsection>
        </section>
        
        <section name="The old Web Services interface" shortname="signserverws">
                <p>
The SignServerWS is the old web services interface now replaced by SignServer ClientWS. It was 
new to version 3.0 and at the time replaced the RMI-SSL interface from version 1.0 and 2.0 for two reasons, the RMI-SSL were based on a commercial library and it only worked for Java clients.
                    </p>
                    <p>
The SignServerWS WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/signserverws/signserverws?wsdl
                    </p>
                    <p>
The interface has two calls, the main one is 'process' which takes a collection of process request to a processable worker and returns a collection of process responses, the second one is getStatus that performs a health check of the node and returns an OK message if the node is healthy.
                    </p>
                    <p>
                        <b>Notice:</b>
All though the SignServerWS interface uses web services the actual process data is base64 encoded byte arrays in a special binary format. You will have to lookup the Java source code for the exact format of the request and response data. An alternative is to instead use the much simpler <a href="#Web%20Server%20Interface">Web Server Interface</a> or the newer <a href="#Client%20Web%20Service">ClientWS interface</a>. 
                    </p>
                    <p>
The getStatus call can be used to implement high-availability towards the client. The Java client API described in the next section have built in support for different high availability policies.
                    </p>
                    <p>
It's possible to turn off the WebService interface by disabling it in the build configuration.
                    </p>
                    <p>
This interface is only supported using HTTPS. The reason is that JBoss 4 does not rewrite the protocol part of the WSDL URL so we had to hard code it for it to work with HTTPS. For details about this see <a href="https://jira.primekey.se/browse/DSS-327">DSS-327</a>. 
                    </p>
                    <p>
Since SignServer >=3.2.1 it is possible to supply extra request data called RequestMetadata containing key/value pairs that can be used by the signers. For instance the PDFSigner uses this feature to let the client supply a PDF password. 
                    </p>
        </section>

		<section name="Java Client API">
                    <p>
Built along with the WebService is a Java API that can be used by clients. It's available in the file lib/SignServer-Client-SignServerWS.jar (the old SignServerWS interface) and lib/SignServer-Client-ClientWS.jar (the ClientWS interface). 
                    </p>
		</section>

		<section name="SigningAndValidation API">
			<p>
				The SigningAndValidation API is a wrapper around the previous
				mentioned API in order to have a simplified interface that also
				is the same regardless if WebService or EJB Remote calls are used.
			</p>
			<p>
				To use the API include the file lib/SignServer-Client-SigningAndValidationAPI.jar.
			</p>
			<subsection name="Sample Code">
				<subsubsection name="Signing and validating an XML document">
                                    <source>
try {
    System.setProperty("javax.net.ssl.trustStore", "p12/truststore.jks");
    System.setProperty("javax.net.ssl.trustStorePassword", "changeit");
  
    ISigningAndValidation signserver = new SigningAndValidationWS("localhost", 8442, true);

    // Document to sign
    byte[] unsigned = "&lt;document&gt;&lt;name&gt;Some content&lt;/name&gt;&lt;/document&gt;".getBytes();
    byte[] signed;

    // Signing
    GenericSignResponse signResp = signserver.sign("DemoXMLSigner", unsigned);
    signed = signResp.getProcessedData();
    System.out.println("Signed: " + new String(signed));

    // Validating
    GenericValidationResponse validateResp = signserver.validate("DemoXMLValidator", signed);
    System.out.println("Valid: " + validateResp.isValid());

    if(validateResp.getSignerCertificate() != null) {
        if(validateResp.getSignerCertificate() instanceof X509Certificate) {
            X509Certificate signerCert = (X509Certificate) validateResp.getSignerCertificate();
            System.out.println("Signed by: " + signerCert.getSubjectDN().getName());
        }
    }
} catch (Exception ex) {
    ex.printStackTrace();
}                                   </source>
				</subsubsection>

			</subsection>
		</section>

                <section name="Web Server Interface">
                    <subsection name="GenericProcessServlet">
                        <p>
				HTTP requests can be sent to the SignServer servlet GenericProcessServlet located at /signserver/process using
                                either POST or GET.
			</p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/process</b></td>
                            </tr>
                            <tr>
                                <td>Method:</td><td><b>GET</b> or <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request content-type:</td><td><b>None</b>, <b>"x-www-form-urlencoded"</b>, <b>"multipart/form-data"</b> or <b>other<sup>*</sup></b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>workerName</b> - Name of the worker that should handle the request. Required unless workerId specified.</li>
                                        <li><b>workerId</b> - Id of the worker that should handle the request. Required unless workerName specified.</li>
                                        <li><b>data</b> - The bytes that should be signed or validated. Required for x-www-form-urlencoded.</li>
                                        <li><b>filerecievefile</b> - File upload used with multipart/form-data.</li>
                                        <li><b>pdfPassword</b> - Password for changing PDF. Optionally and only used by PDFSigner.</li>
                                        <li><b>encoding</b> - Encoding of the data field. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the worker.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td>
                                <td>
                                    <ul>
                                        <li><b>HTTP 200</b> (OK): The request was successfull</li>
                                        <li><b>HTTP 400</b> (Bad Request): The request could not be fulfilled. Some request data were missing or incorrect etc.</li>
                                        <li><b>HTTP 401</b> (Unauthorized): The worker requires user authentication</li>
                                        <li><b>HTTP 404</b> (Not Found): The requested workerName or workerId does not represent an existing worker</li>
                                        <li><b>HTTP 413</b> (Request Entity Too Large): The data field or uploaded file is too large</li> 
                                        <li><b>HTTP 500</b> (Internal Server Error): There was an internal error when processing the request. Typically indicating an configuration problem or unexpected error at the server side.</li>
                                        <li><b>HTTP 503</b> (Service Unavailable): The worker is not active, its crypto token is not activated or similar</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td>Depending on the worker</td>
                            </tr>
                        </table>
                        <p>
                            <sup>*</sup> if the request content-type in a POST is specified as something else than "x-www-form-urlencoded" or
                            "multipart/form-data" the message body is not parsed but instead directly passed to the worker specified by workerName or workerId
                            in the URI's query string.
                        </p>

                        <subsubsection name="Samples">
                            <ul>
                                <li>
                                    HTTP GET:<br/>
                                    http://localhost:8080/signserver/process?workerName=DemoXMLSigner&amp;data=%3Croot%3Ehej2%3C/root%3E<br/>
                                    http://localhost:8080/signserver/process?workerName=DemoXMLSigner&amp;encoding=base64&amp;data=PGhlajI%2Bb2s8L2hlajI%2BCg%3D%3D<br/>
                                    <br/>
                                </li>
                                <li>
                                    HTTP POST with multipart/form-data or x-www-form-urlencoded:<br/>
                                    For example see /signserver/demo/xmlsign.jsp (multipart/form-data) and /signserver/demo/genericsign.jsp (x-www-form-urlencoded).<br/>
                                    <br/>
                                </li>
                                <li>
                                    HTTP POST with other content-type:<br/>
                                    See the TimeStampClient.<br/>
                                    <br/>
                                </li>
                            </ul>
                        </subsubsection>

                    </subsection>
                    <subsection name="WorkerServlet">
                        <p>
				HTTP requests can be sent to the SignServer servlet WorkerServlet located at /signserver/worker/* using
                                either POST or GET.<br/>
                Requests are forwarded to the GenericProcessServlet, except that the worker name is taken from the URL.<br/>
                            Worker name or ID given through request parameters are ignored.
			</p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/worker/*</b> (* denotes a worker name)</td>
                            </tr>
                            <tr>
                                <td>Method:</td><td><b>GET</b> or <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request content-type:</td><td><b>None</b>, <b>"x-www-form-urlencoded"</b>, <b>"multipart/form-data"</b> or <b>other<sup>*</sup></b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>data</b> - The bytes that should be signed or validated. Required for x-www-form-urlencoded.</li>
                                        <li><b>filerecievefile</b> - File upload used with multipart/form-data.</li>
                                        <li><b>pdfPassword</b> - Password for changing PDF. Optionally and only used by PDFSigner.</li>
                                        <li><b>encoding</b> - Encoding of the data field. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the worker.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td>
                                <td>
                                    <ul>
                                        <li><b>HTTP 200</b> (OK): The request was successfull</li>
                                        <li><b>HTTP 400</b> (Bad Request): The request could not be fulfilled. Some request data were missing or incorrect etc.</li>
                                        <li><b>HTTP 401</b> (Unauthorized): The worker requires user authentication</li>
                                        <li><b>HTTP 404</b> (Not Found): The requested workerName or workerId does not represent an existing worker</li>
                                        <li><b>HTTP 413</b> (Request Entity Too Large): The data field or uploaded file is too large</li> 
                                        <li><b>HTTP 500</b> (Internal Server Error): There was an internal error when processing the request. Typically indicating an configuration problem or unexpected error at the server side.</li>
                                        <li><b>HTTP 503</b> (Service Unavailable): The worker is not active, its crypto token is not activated or similar</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td>Depending on the worker</td>
                            </tr>
                        </table>

                        <subsubsection name="Samples">
                            <ul>
                                <li>
                                    HTTP GET:<br/>
                                    http://localhost:8080/signserver/worker/DemoXMLSigner?data=%3Croot%3Ehej2%3C/root%3E<br/>
                                    http://localhost:8080/signserver/worker/DemoXMLSigner?encoding=base64&amp;data=PGhlajI%2Bb2s8L2hlajI%2BCg%3D%3D<br/>
                                    <br/>
                                </li>
                            </ul>
                        </subsubsection>

                    </subsection>
                    <subsection name="SODProcessServlet">
                        <p>
                            Servlet recieving HTTP POST requests containing data group hashes
                            and creates a MRTDSODSignerRequest and passes it to the specified
                            MRTDSODSigner. The response from the servlet is the signed security
                            object in binary format.
                        </p>
                        <table>
                            <tr>
                                <td>URL:</td><td><b>/signserver/sod</b></td>
                            </tr>
                            <tr>
                                <td>Method:</td><td> <b>POST</b></td>
                            </tr>
                            <tr>
                                <td>Request parameters:</td>
                                <td>
                                    <ul>
                                        <li><b>workerName</b> - Name of the worker that should handle the request. Required unless workerId specified.</li>
                                        <li><b>workerId</b> - Id of the worker that should handle the request. Required unless workerName specified.</li>
                                        <li><b>dataGroup1 to dataGroup16</b> - The data group hashes that should be put in the SO(d). At least one required.</li>
                                        <li><b>encoding</b> - Encoding of the data group hash fields. Optional. By specifying "base64" SignServer Base64-decodes
                                        the data property before passing it to the MRTDSODSigner.</li>
                                        <li><b>ldsVersion</b> - Request a specific LDS version: "0107" for V1.7 or "0108" for V1.8. Optional. If not specified the version from the configuration is used. If version is V1.8 unicodeVersion also needs to be specified.</li>
                                        <li><b>unicodeVersion</b> - Unicode version to store in the SOd. Optional. Only supported if ldsVersion "0108" specified. Specify "040000" for Unicode version 4.0.0.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Response code:</td><td>The same response codes as for the GenericProcessServlet are used.</td>
                            </tr>
                            <tr>
                                <td>Response content-type:</td><td><b>application/octet-stream</b></td>
                            </tr>
                        </table>


                        <subsubsection name="Samples">
                            <ul>
                                <li>
                                    See /signserver/demo/mrtdsodsign.jsp.<br/>
                                    <br/>
                                </li>
                            </ul>
                        </subsubsection>
                    </subsection>
		</section>

                <section name="Client Command Line Interface (CLI)" shortname="clientcli">
                    <p>
Requests can be sent to the workers using the Client CLI. After building
SignServer the script bin/client.sh can be run.
                    </p>
                    <source>
$ bin/client.sh
INFO  usage: client &lt;signdocument | validatedocument | timestamp | validatecertificate | signdatagroups&gt;
                    </source>

                    <subsection name="signdocument">
                        <p>
Request signing of a document using HTTP(s) or web services. 
                        </p>
                        <source>
usage: signdocument &lt;-workername WORKERNAME | -workerid WORKERID&gt;
                    [options]
Request a document to be signed by SignServer
 -data             Data to send to the worker.
 -host             Server name or IP address. Default: localhost
 -infile           File to read data to send to the worker from.
 -keyalias         Alias of the key in the keystore to use for
                   authentication.
 -keystore         Keystore with private key and certificate for client
                   certificate authentication.
 -keystorepwd      Password for reading the keystore.
 -outfile          File to write the result to. If not specified the
                   result is written to stdout.
 -password         Password for authentication.
 -pdfpassword      Password for changing the PDF (if required).
 -port             Server port. Default: 8080 (for HTTP), 8442 for HTTPS
                   and 8443 for HTTPS with client authentication.
 -protocol         Method of interacting with SignServer. HTTP,
                   CLIENTWS or WEBSERVICES. Default: HTTP.
 -servlet          Servlet to call. Default /signserver/process
 -truststore       Keystore with trusted certificates to use with HTTPS.
 -truststorepwd    Password for the keystore with trusted certificates.
 -username         Username for authentication.
 -workerid         ID of worker which should perform the operation.
 -workername       Name of worker which should perform the operation.

Sample usages:
a) signdocument -workername XMLSigner -data "&lt;root/&gt;"
b) signdocument -workername XMLSigner -infile /tmp/document.xml
c) signdocument -workerid 2 -data "&lt;root/&gt;" -truststore truststore.jks
-truststorepwd changeit
d) signdocument -workerid 2 -data "&lt;root/&gt;" -keystore superadmin.jks
-truststorepwd foo123
                        </source>
                    </subsection>

                    <subsection name="validatedocument">
                        <p>
Request a document to be validated.
                        </p>
                        <source>
usage: validatedocument &lt;-workername WORKERNAME | -workerid WORKERID&gt;
                        [options]
Request a document to be validated by SignServer
 -data             Data to send to the worker.
 -host             Server name or IP address. Default: localhost
 -infile           File to read data to send to the worker from.
 -keyalias         Alias of the key in the keystore to use for
                   authentication.
 -keystore         Keystore with private key and certificate for client
                   certificate authentication.
 -keystorepwd      Password for reading the keystore.
 -password         Password for authentication.
 -port             Server port. Default: 8080 (for HTTP), 8442 for HTTPS
                   and 8443 for HTTPS with client authentication.
 -truststore       Keystore with trusted certificates to use with HTTPS.
 -truststorepwd    Password for the keystore with trusted certificates.
 -username         Username for authentication.
 -workerid         ID of worker which should perform the operation.
 -workername       Name of worker which should perform the operation.

Sample usages:
a) validatedocument -workername XMLValidator -data "&lt;root&gt;&lt;Signature...
b) validatedocument -workername XMLValidator -infile /tmp/signed.xml
c) validatedocument -workerid 2 -infile /tmp/signed.xml -truststore
truststore.jks -truststorepwd changeit
d) validatedocument -workerid 2 -infile /tmp/signed.xml -keystore
superadmin.jks -truststorepwd foo123
                        </source>
                    </subsection>

                    <subsection name="timestamp">
                        <source>
$ bin/client.sh timestamp
usage: signclient timestamp &lt;options&gt; &lt;url&gt;
 -base64                Give this option if the stored request/reply
                        should be base64 encoded, default is not.
 -certreq               Request signer certificate
 -help                  Print this message.
 -infile &lt;file&gt;         File containing message to time stamp.
 -inrep &lt;file&gt;          Input file containing an earlier stored base64
                        encoded response, to verify.You must specify the
                        verify flag also.
 -inreq &lt;file&gt;          Input file containing an earlier stored request to
                        use instead of creating a new. You must specify
                        the request flag also.
 -instr &lt;string&gt;        String to be time stamped, if neither instr or
                        infile is given, the client works in test-mode
                        generating it's own message.
 -keyalias &lt;arg&gt;        Alias of the key in the keystore to use for
                        authentication.
 -keystore &lt;arg&gt;        Keystore with private key and certificate for
                        client certificate authentication.
 -keystorepwd &lt;arg&gt;     Password for reading the keystore.
 -outrep &lt;file&gt;         Output file to store the recevied TSA reply, if
                        not given the reply is not stored.
 -outreq &lt;file&gt;         Output file to store the sent TSA request, if not
                        given the request is not stored.
 -reqpolicy &lt;oid&gt;       Request timestamp issued under a policy OID
 -signerfile &lt;file&gt;     Input file containing the PEM encoded certificate
                        of the TSA signer.Used to verify a stored
                        response.
 -sleep &lt;num&gt;           Sleep a number of milliseconds after each request.
                        Default 1000 ms.
 -truststore &lt;arg&gt;      Keystore with trusted certificates to use with
                        HTTPS.
 -truststorepwd &lt;arg&gt;   Password for the keystore with trusted
                        certificates.
 -url &lt;url&gt;             Url of TSA, e.g.
                        http://127.0.0.1:8080/signserver/process?workerId=
                        1.
 -verify                Give this option if verification of a stored reply
                        should be done, work together with inrep and
                        cafile. If given, no request to the TSA will
                        happen.

Sample usages:
a) timestamp -url http://localhost:8080/signserver/tsa?workerName=TimeStampSigner
                        </source>
                    </subsection>

                    <subsection name="validatecertificate">
                        <p>
Request a certificate to be validated by the specified service.
                        </p>
                        <source>
usage: Usage: java -jar validate.jar &lt;options&gt;

 -cert &lt;cert-file&gt;              Path to certificate file (DER or PEM)
                                (Required).
 -certpurposes &lt;certpurposes&gt;   A ',' separated string containing
                                requested certificate purposes.
 -der                           Certificate is in DER format.
 -help                          Display this info
 -hosts &lt;hosts&gt;                 A ',' separated string containing the
                                hostnames of the validation service nodes. Ex
                                'host1.someorg.org,host2.someorg.org' (Required).
 -pem                           Certificate is in PEM format (Default).
 -port &lt;port&gt;                   Remote port of service (Default is 8080 or
                                8442 for SSL).
 -service &lt;service-name&gt;        The name or id of the validation service
                                to process request. (Required)
 -silent                        Don't produce any output, only return
                                value.
 -truststore &lt;jks-file&gt;         Path to JKS truststore containing trusted
                                CA for SSL Server certificates.
 -truststorepwd &lt;password&gt;      Password to unlock the truststore.

The following values is returned by the program that can be used when scripting.
  -2   : Error happened during execution
  -1   : Bad arguments
   0   : Certificate is valid
   1   : Certificate is revoked
   2   : Certificate is not yet valid
   3   : Certificate have expired
   4   : Certificate doesn't verify
   5   : CA Certificate have been revoked
   6   : CA Certificate is not yet valid
   7   : CA Certificate have expired.
   8   : Certificate have no valid certificate purpose.

Sample usages:
a) validatecertificate -service CertValidationWorker -hosts localhost -cert
    certificate.pem
b) validatecertificate -service 5806 -hosts localhost -cert certificate.pem
    -truststore p12/truststore.jks -truststorepwd changeit
                        </source>
                    </subsection>

                    <subsection name="signdatagroups">
                        <p>
Sign the specified data groups and produce an SOd (MRTD).
                        </p>
                        <source>
$ bin/client.sh signdatagroups
usage: signdatagroups &lt;options&gt;
Request MRTD data groups to be signed
 -data &lt;arg&gt;            Data to send to the worker.
 -encoding &lt;arg&gt;        Encoding of the data option. None or base64.
                        Default: none.
 -host &lt;arg&gt;            Server name or IP address. Default: localhost
 -keyalias &lt;arg&gt;        Alias of the key in the keystore to use for
                        authentication.
 -keystore &lt;arg&gt;        Keystore with private key and certificate for
                        client certificate authentication.
 -keystorepwd &lt;arg&gt;     Password for reading the keystore.
 -password &lt;arg&gt;        Password for authentication.
 -port &lt;arg&gt;            Server port. Default: 8080 (for HTTP), 8442 for
                        HTTPS and 8443 for HTTPS with client
                        authentication.
 -protocol &lt;arg&gt;        Method of interacting with SignServer. HTTP or
                        CLIENTWS. Default: HTTP.
 -repeat &lt;arg&gt;          Run the operation this number of times. Default: 1
 -servlet &lt;arg&gt;         Servlet to call. Default /signserver/sod
 -truststore &lt;arg&gt;      Keystore with trusted certificates to use with
                        HTTPS.
 -truststorepwd &lt;arg&gt;   Password for the keystore with trusted
                        certificates.
 -username &lt;arg&gt;        Username for authentication.
 -workerid &lt;arg&gt;        ID of worker which should perform the operation.
 -workername &lt;arg&gt;      Name of worker which should perform the operation.

Sample usages:
a) signdatagroups -workername MRTDSODSigner -data "1=value1&amp;2=value2&amp;3=value3"
                        </source>
                    </subsection>

                </section>

                <section name="Administration Web Service" shortname="adminws">
                    <p>
The SignServer AdminWS can be used for remote administration of SignServer
over client authenticated HTTPS. Access is granted based on a list of
certificate serial number and issuer distinguished name pairs. Currently there
is only one access level and all administrators granted access will be able to
perform all operations.
                    </p>
                    <p>
The WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/AdminWSService/AdminWS?wsdl
                    </p>
                    <p>
Authorizing administrators can be done using the Admin CLI command "wsadmins".
                    </p>
                    <source>
Usage: signserver wsadmins -add -certserialno &lt;certificate serial number&gt; -issuerdn &lt;issuer DN&gt;
Usage: signserver wsadmins -remove -certserialno &lt;certificate serial number&gt; -issuerdn &lt;issuer DN&gt;
Usage: signserver wsadmins -list
Example 1: signserver wsadmins -add -certserialno 123abcdef -issuerdn "C=SE, CN=Neo Morpheus"
Example 2: signserver wsadmins -remove -certserialno 123abcdef -issuerdn "C=SE, CN=Neo Morpheus"
Example 3: signserver wsadmins -list
                    </source>
                    <p>
Notice that the certificate serial number should be entered with lower case characters. 
Also notice that the issuer DN currently should be entered in the reversed order 
and with spaces after each component. In the example above the issuer DN from the 
certificate actually is "CN=Neo Morpheus, C=SE". 
                    </p>
                    <p>
To troubleshoot an "Administrator not authorized to resource" see the logs for how 
SignServer interprets the serialnumber and subject DN. Example:
                    </p>
                    <pre>
19:00:33,946 INFO  [AdminWS] ADMIN OPERATION; subjectDN=C=SE, O=Markus Organization, OU=Internal Testing 1, CN=External RA Admin 1; serialNumber=4a3442e98e3ce428; issuerDN=C=SE, O=Markus Organization, OU=Internal Testing 1, CN=MarkusAdminCA1; authorized=false; operation=getWorkers; arguments=
                    </pre>
                </section>
                
                <section name="Apache HTTP Server as proxy">
                    <p>
This section will show you examples on how the Apache Web Server (version 2.2.20) can be used as a proxy in front of SignServer. This guide is only informative, you should also always consult the current Apache documentation for the modules used. The proxy could be used for multiple reasons including:
                    </p>
                    <ul>
                        <li>Use standard ports (80, 443) instead of unprivileged ports used by the application server</li>
                        <li>Making workers accessible through more nice looking URLs.<br/>For example "http://tsa.example.com" instead of "http://example.com:8080/signserver/tsa?workerName=TimeStampSigner1"</li>
                        <li>Use any of the access control and authentication mechanism available in Apache</li>
                        <li>Redirect HTTP traffic to HTTPS</li>
                        <li>Only accepting requests to specified locations</li>
                    </ul>
                    <p>
As the requests should go through the proxy you will probably want to configure the application server to only listen to localhost and/or use a firewall blocking the application server ports from external requests. To configure JBoss to only listen to localhost set the following properties in signserver_build.properties:
                    </p>
                    <source>
httpsserver.bindaddress.pubhttp=127.0.0.1
httpsserver.bindaddress.pubhttps=127.0.0.1
httpsserver.bindaddress.privhttps=127.0.0.1
                </source>
                    <p>
Install the Apache web server and enable required modules (the following commands are for Ubuntu but should be similar in other distributions as well):
                    </p>
                <source>
$ sudo apt-get install apache2
$ cd /etc/apache2/mods-enabled/
$ sudo ln -s ../mods-available/proxy.load proxy.load
$ sudo ln -s ../mods-available/proxy_http.load proxy_http.load
$ sudo ln -s ../mods-available/proxy_ajp.load proxy_ajp.load
$ sudo ln -s ../mods-available/proxy_balancer.load proxy_balancer.load
$ sudo ln -s ../mods-available/rewrite.load rewrite.load
$ sudo ln -s ../mods-available/ssl.load ssl.load
                </source>
    
   
                <subsection name="Example: Rewrite URLs for TSA (using mod_proxy and mod_rewrite)">
   
                    <p>
A sample configuration how to fix up nice URLs for time-stamping so that you can point your TSA clients to http://tsa.example.com/ instead of http://tsa.example.com:8080/signserver/process?workerName=TimeStampSigner1.
                    <br/>
This configuration combines mod_proxy with mod_rewrite to be able to set the workerName or workerId, so you can have different TSAs available on different URLs.
                    </p>
                    <source>
&lt;VirtualHost tsa.example.com:80>
    ServerName tsa.example.com
    ServerAlias tsa.example.com
    CustomLog /var/log/apache2/access.log combined

    RewriteEngine on
    RewriteLogLevel 5
    RewriteLog "/var/log/apache2/rewrite.log
    RewriteRule ^/$ /?workerName=TimeStampSigner1 [PT]

    ProxyRequests Off
    &lt;Proxy *&gt;
        Order deny,allow
        Allow from all
    &lt;/Proxy&gt;
    ProxyPass / http://127.0.0.1:8080/signserver/process
    ProxyPassReverse / http://127.0.0.1:8080/signserver/process
&lt;/VirtualHost>
                    </source>
                </subsection>
                
                <subsection name="Example: Rewrite URLs and redirect to HTTPS (using AJP)">
                    <p>
The following example configures three virtual hosts. The first signserver.example.com:80 just redirects all requests to use HTTPS and thus the virtual host signserver.example.com:443. The second virtual host is configured to proxy requests to the /signserver path on the application server using the AJP protocol. It is also configured to use HTTPS with a server certificate. The last virtual hosts auth.signserver.example.com using an additonal IP address is configured to require client certificate authentication. 
                    </p>
                    <p>
Notice: Some application servers (i.e. JBoss 4) might have problems writing the correct port number in the endpoint URL in the web services WSDL file when using a proxy (i.e. writing 8443 instead of 443).
                    </p>
                    <source><![CDATA[
<VirtualHost signserver.example.com:80>
    ServerName signserver.example.com
    ServerAlias signserver.example.com

    RewriteEngine On
    RewriteCond %{HTTPS} off
    RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI}

    # Configure log
    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined

</VirtualHost>

<VirtualHost signserver.example.com:443>
    ServerName signserver.example.com
    ServerAlias signserver.example.com

    ProxyRequests Off
    <Proxy balancer://mycluster-3>
        BalancerMember ajp://localhost:8009/signserver
    </Proxy>
    ProxyPass / balancer://mycluster-3/

    RewriteEngine   On

    # Treat requests to / and /signserver/ as the same for web services endpoints to work.
    RewriteCond     %{THE_REQUEST}  /signserver/
    RewriteRule     ^/signserver/(.*)$ /$1 [PT]

    # Configure secure SSL for this server using SSL certificate generated by EJBCA
    SSLEngine on
    SSLCipherSuite HIGH
    SSLProtocol all -SSLv2
    SSLCertificateFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/signserver.example.com-cert.pem
    SSLCertificateKeyFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/signserver.example.com-key.pem

    # Configure log
    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined
</VirtualHost>

# Note: auth.signserver.example.com must have a different IP address
<VirtualHost auth.signserver.example.com:443>
    ServerName auth.signserver.example.com
    ServerAlias auth.signserver.example.com

    ProxyRequests Off
    <Proxy balancer://mycluster-4>
        BalancerMember ajp://localhost:8009/signserver
    </Proxy>
    ProxyPass / balancer://mycluster-4/

    RewriteEngine   On
    # Treat requests to / and /signserver/ as the same for web services endpoints to work.
    RewriteCond     %{THE_REQUEST}  /signserver/
    RewriteRule     ^/signserver/(.*)$ /$1 [PT]

    # Configure secure SSL for this server using SSL certificate generated by EJBCA
    SSLEngine on
    SSLCipherSuite HIGH
    SSLProtocol all -SSLv2
    SSLCertificateFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/auth.signserver.example.com-cert.pem
    SSLCertificateKeyFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/auth.signserver.example.com-key.pem

    SSLVerifyClient require
    SSLVerifyDepth 1
    SSLCACertificateFile /home/markus/Documents/PrimeKey/MarkusCA/example.com/truststore.pem

    # Configure log
    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined
</VirtualHost>]]>
                    </source>
                </subsection>
                
                <subsection name="Example: Granting access to specific workers only">
                    <p>
This example shows how it is possible to limit access to only specified resources. 
                    </p>
                    <p>
If you are going to grant different users access to different workers always remember to first deny access from the root location. The reason is that there are other ways to access a worker than the "/worker/*" pattern. For instance /process, /tsa, /pdf and /sod etc as well as using the web services interfaces /signserverws, /SignServerWSService, /validationws, /ValidationWSService and /ClientWSService all can be used to invoke <b>any</b> worker.
                    </p>
                    <p>
If you instead relay on SignServer to do the authentication/authorization it could still be good from a security point to only grant access to the locations you intend to use. In that case you would probably want to also give access to the  web services interfaces, /worker and /process etc.
                    </p>
                    <p>
Also remember if you are proxying from multiple virtual hosts (i.e. if you have one with and one without client authentication as in the example above) that you might want to add the access restrictions to all of them.
                    </p>
                    <source><![CDATA[
    ...
    # First, deny access globally and then only give access to resources explicitly
    <Location />
    	Order Deny,Allow
    	Deny from all
    </Location>

    # Allow index page
    <LocationMatch "^/$">
	Order Allow,Deny
	Allow from all
    </LocationMatch>

    # Allow demo web pages
    <Location /demo/>
	Order Allow,Deny
	Allow from all
    </Location>

    # Allow documentation
    <Location /doc/>
	Order Allow,Deny
	Allow from all
    </Location>

    # Allow web page resources
    <LocationMatch "\.(css|js|jpg|png)$">
	Order Allow,Deny
	Allow from all
    </LocationMatch>
    
    # Allow the Admin interface
    <Location /AdminWSService/>
	Order Allow,Deny
	Allow from all
    </Location>

    # Grant everybody access to the XMLSigner
    <Location /worker/XMLSigner>
	Order Allow,Deny
	Allow from all
    </Location>

    # Grant valid users access to the CMSSigner
    <Location /worker/CMSSigner>
	Order Allow,Deny
        Allow from all
        AuthType Basic
        AuthName "Restricted CMSSigner access"
    	AuthUserFile /home/markus/.htpasswd
    	Require valid-user
    </Location>
    ...]]>
                    </source>
                </subsection>
                
            </section>
        </chapter>

        <chapter name="Common configuration" shortname="commonconf">

		<p>
		Configuring workers are done by setting properties in the worker configuration.
		There is one set of configuration options that are handled by the framework, and that applies to all workers, then there are worker specific properties handled by the worker implementation.
		</p>
		<p>Properties are usually defined in the module configuration file used to install a module, or configured manually using one of the <i>bin/signserver setproperty</i> variant.</p>
		
            <section name="Setting Authorization Type">
                <subsection name="SignServer">
                    <p>
By default (if the property is not set) is client-certificate authentication required for a signature request to be processed. This can be changed with the AUTHTYPE property.
                    </p>
                    <subsubsection name="No authentication">
                        <p>
<b>AUTHTYPE</b> =  NOAUTH
                        </p>
                        <p>
Sets the server to not require any authentication.
                        </p>
                    </subsubsection>
                    <subsubsection name="Client certificate authentication">
                        <p>
<b>AUTHTYPE</b> =  CLIENTCERT
                        </p>
                        <p>
 (default) requires a certificate of all the clients. The certificates must be 
 in the application server's truststore. Authorized clients is configured
 manually using the CLI interface.
                        </p>
                    </subsubsection>
                    <subsubsection name="Username/password-based authentication">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.UsernamePasswordAuthorizer
                        </p>
                        <p>
<b>USER.[NAME]</b> = [PASSWORD]<br/>
<b>USER.[NAME]</b> = [HASHED_PASSWORD]:[HASH_ALGORITHM]<br/>
<b>USER.[NAME]</b> = [HASHED_PASSWORD]:[HASH_ALGORITHM]:[SALT]<br/>
                        </p>
                        <p>
This authorizer requires a valid username and password. User accounts are
configured by setting properties of the form shown above, where
[NAME] is the username and [PASSWORD] is the clear-text password. In the second
form [HASHED_PASSWORD] should be replaced with the output of the digest algorithm 
specified in [HASH_ALGORITHM]. The third form uses a hash value that is appended 
to the password before hashing it.
                        </p>
                        <p>
If a valid username and
password is not supplied the worker throws an AuthorizationRequiredException
which in case of the HTTP interfaces causes a HTTP Basic Authentication (RFC 2617).
                        </p>
                    </subsubsection>
                    <subsubsection name="Username-based authentication">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.UsernameAuthorizer
                        </p>
                        <p>
Form 1: ACCEPT_ALL_USERNAMES = false (default) and usernames are specified:<br/>
<b>ACCEPT_ALL_USERNAMES</b> = false<br/>
<b>ACCEPT_USERNAMES</b> = user1;user2;user3
                        </p>
                        <p>
Form 2, ACCEPT_ALL_USERNAMES = true and no usernames are specified:<br/>
<b>ACCEPT_ALL_USERNAMES</b> = true
                        </p>
                        <p>
An Authorizer that can be used for instance if SignServer sits behind an Apache
front-end which uses HTTP basic authentication. With this Authorizer the username
is logged but the password is not checked as it is assumed to be checked by the
front-end.
                        </p>
                        <p>
The Authorizer can be configured to either accept all usernames or only accept
those usernames listed in one of its properties.
                        </p>
                    </subsubsection>
                    <subsubsection name="Remote address authentication">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.RemoteAddressAuthorizer
                        </p>
                        <p>
<b>ALLOW_FROM</b> = Comma separated list of IP addresses to allow requests from.
By default all other addresses are denied access.
                        </p>
                        <p>
If a worker is invoked directly using an EJB call and no REMOTE_IP is specified
in the RequestContext the IP-address is set to the String "null". In that case,
to allow requests using EJB calls, null can be added to the list of allowed
addresses.
                        </p>
                        <p>
<b>Note:</b> When adding "null" to ALLOW_FROM not only locally running clients
like the ClientCLI and AdminGUI is allowed access but also from workers that
invoke the other worker directly using an EJB call. This is for instance the
case for the XMLValidator which delegates the validation of the certificate to
a CertValidator. If the CertValidator had a RemoteAddressAuthorizer allowing
access from "null" then the XMLValidator would be able to use it. To restrict
users from using the CertValidator (indirectly through the XMLValidator) an
Autorizer could be configured for the XMLValidator.
                        </p>
                        <p>
<b>Logging:</b> This authorizer will add the remote IP address to the log field AUTHORIZED_ADDRESS.
                        </p>
                    </subsubsection>
                    <subsubsection name="List-based Address Authorizer">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.ListBasedAddressAuthorizer
                        </p>
                        <p>
An authorizer that supports white- and blacklisting direct and forwarded addresses (coming via a proxy).
                        </p>
                        <p>
<b>WHITELISTED_DIRECT_ADDRESSES</b> = A comma-separated list of IP addresses allowed direct access.
                        </p>
                        <p>
<b>BLACKLISTED_DIRECT_ADDRESSES</b> = A comma-separated list of IP addresses denied direct access.
                        </p>
                        <p>
<b>WHITELISTED_FORWARDED_ADDRESSES</b> = A comma-separated list of IP addresses allowed access as a forwarded address.
                        </p>
                        <p>
<b>BLACKLISTED_FORWARDED_ADDRESSES</b> = A comma-separated list of IP addresses denied access as a forwarded address.
                        </p>
                        <p>
It is not possible to specify both a whitelist and a black list at the same time for each of direct and forwarded addresses.
One of each list (direct and forwarded) must be specified.
When specifying a whitelist for forwarded addresses, requests without an X-Forwarded-For header will always be denied.
Only the last address in the X-Forwarded-For header is considered (in the case of using multiple proxies).
                        </p>
                        <p>
Examples:
                        </p>
                        <p>
1. To accept requests from all direct addresses except for 10.0.0.5 and for all forwarded addresses except 13.170.18.12 and 13.170.18.13 use:<br/>
BLACKLISTED_DIRECT_ADDRESSES=10.0.0.5<br/>
BLACKLISTED_FORWARDED_ADDRESSES=13.170.18.12, 13.170.18.13
                        </p>
                        <p>
2. To only accept direct requests from 10.0.0.1 and 10.0.0.2 and from the forwarded address 216.34.181.97 use:<br/>
WHITELISTED_DIRECT_ADDRESSES=10.0.0.1, 10.0.0.2<br/>
WHITELISTED_FORWARDED_ADDRESS=216.34.181.97
                        </p>
                        <p>
3. To only allow direct access from the proxy servers 10.0.0.1 and 10.0.0.2 but allow them to forward from all address except the to banned addresses 13.170.18.12 and 13.170.18.13 use:<br/>
WHITELISTED_DIRECT_ADDRESSES=10.0.0.1, 10.0.0.2<br/>
BLACKLISTED_FORWARDED_ADDRESSES=13.170.18.12, 13.170.18.13
                        </p>
                        <p>
4. To accept direct requests from all addresses except 10.0.0.5 but only forwarded from 216.34.181.97 use:<br/>
BLACKLISTED_DIRECT_ADDRESSES=10.0.0.5<br/>
WHITELISTED_FORWARDED_ADDRESS=216.34.181.97
                        </p>
                        <p>
<b>Logging:</b> This authorizer will add the remote IP address to the log field AUTHORIZED_ADDRESS and the proxied address
(if it's available in the request) in the log field AUTHORIZED_FORWARDED_ADDRESS.
                        </p>
  
                    </subsubsection>
                    <subsubsection name="DispatchedAuthorizer">
                        <p>
<b>AUTHTYPE</b> = org.signserver.server.DispatchedAuthorizer    
                        </p>
                        <p>
<b>AUTHORIZEALLDISPATCHERS</b> = True, if any Dispatcher should be authorized. (Default: true, currently only true is supported)
                        </p>
                        <p>
Only accepts requests that has gone through a Dispatcher. This Authorizer only checks the present of the DISPATCHER_AUTHORIZED_CLIENT field in the request context to know that the request has passed a Dispatcher.
                        </p>
                    </subsubsection>
                    <subsubsection name="Custom">
                        <p>
This authorization functionality doesn't work for all use cases. Then it's possible to create a customized authorizer and specify it's class path as value in the AUTHTYPE property. The Processable will then automatically instantiate and use it. How to develop such a plug-in is explained in the developers section.
                        </p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="Archiving Responses">
                <p>
The archiving feature can be used to save all generated responses.    
                </p>
                <p>
For the OldDatabaseArchiver and Base64DatabaseArchiver, in some extent, the Admin CLI can be used to query the archive. See 
the CLI section for more information.
                </p>
                <p>
When a request has been process each Archiver is called one at the time to archive 
any results.
                </p>
                <p>
<b>ARCHIVERS</b>: Used instead of the old ARCHIVE property to enable archiving 
by listing the class names of all the Archivers that should be used. Multiple 
Archivers can be specified separated by a "," (comma character). Exempel: 
                </p>
<source>
ARCHIVERS=org.signserver.server.archive.olddbarchiver.OldDatabaseArchiver,org.signserver.server.archive.otherarchiver.OtherArchiver123
</source>
                <p>
<b>ARCHIVE</b>: Previously the archiving was enabled by setting the property to 
"TRUE". This is the same as to set 
                </p>
<source>
ARCHIVERS=org.signserver.server.archive.olddbarchiver.OldDatabaseArchiver
</source>
                <p>
Default: FALSE.
                </p>
                <p>
See also the section about all <a href="complete.en.html#Archivers">available Archivers</a>.
                </p>
            </section>

            <section name="Checking validity of signer certificates">
                <p>
By default the SignServer checks if the signer certificate of a signer is valid before letting the signer process a request. If the signers certificate is not valid an error message is returned.
There are two properties that can be set to disable this check:
                </p>
                <p>
<b>CHECKCERTVALIDITY</b>: default value is true, meaning that the validity period of the certificate will be verified before processing. Set to false to ignore if the certificate is expired or not yet valid.
                </p>
                <p>
<b>CHECKCERTPRIVATEKEYVALIDITY</b>: default value is true, meaning that the validity period in the PrivateKeyUsagePeriod of the certificate will be verified before processing. This is only done if this extension exists (it is optional in a certificate). Set to false to ignore the PrivateKeyUsagePeriod.
                </p>
                <p>
<b>MINREMAININGCERTVALIDITY</b>: default value is 0. This property defines a minimum remaining validity time required of the signing certificate. If the signing certificate expires within the number of days specified an error occurs. Set to 0 (default) to disable this check.
				</p>
            </section>

			<section name="Limiting the number of signatures">
                <p>
By default SignServer keeps track of the number of signings performed with each key by holding counters in the database that are updated for each signing. The following worker properties controls the key usage counter:    
                </p>
                <p>
<b>KEYUSAGELIMIT</b> = Sets how many signatures that are allowed to be created
with the same key by this worker (default is -1 = no limit). After the limit has
been reached the worker is considered offline.

Note that the counter is per key and not per worker so if multiple workers share
the same key they will all increment the counter. This also means that the worker
is active again after it has gotten a new certificate/key.
                </p>
                <p>
<b>DISABLEKEYUSAGECOUNTER</b> = By default all key usages are counted but by specifying this as "TRUE" key usages performed by this worker will not be counted. Disabling the key usage counter can be a gain in performance as it will be less database transactions. However, if you have requirements on the number of allowed signings for one worker make sure to not use the same key with another worker for which the counter is disabled as those uses will then be missed.
                </p>
                <p>
The key usage counter can not be disabled for a worker if KEYUSAGELIMIT is also specified.
                </p>
			</section>
            
            <section name="Other properties">
                <p>
<b>DISABLED</b> = Setting this to true disables a worker. A disabled worker can not perform any operations and any requests to it will fail. However, disabled workers are not included in the Health check report. 
                </p>
            </section>
		</chapter>
		
        <chapter name="Plugins" shortname="plugins">
            <!--<p> TODO:
from: manual31.odt:ch7, src
There could also be a listing of all modules and for each module:
a description of its purpose and
description of each of its properties.
            </p>-->
            <section name="Configuring a plug-in">
                <p>
A worker component is configured by entering its class path (and optionally its crypto token class path) in a memory bank called the global configuration and then issuing the reload command. There exists sample configurations for most of the plug-ins in the 'doc/sample-configs' directory.
                </p>
            </section>

            <section name="SignServer Signers">
                <p>
There exists multiple signers. One is the time stamp signer generating RFC 3161 compliant timestamps using the Bouncycastle library.
An MRTD signer creating "Machine Reader Travel Document" signatures using the RSA algorithm from pre-padded data and
another is the MRTD SOD Signer which creates the complete Security Object (SOd) by signing the datagroups for the passport.
There are also signers for automatically signing of specific document-types 
such as PDF, XML, ODF and OOXML and there is a general purpose signer that
can sign any document-type and produces the output in Cryptographic Message Syntax (CMS).
                </p>

                <subsection name="Time-stamp Signer">
                    <p>
The time-stamp signer has the class name: org.signserver.server.signers.TimeStampSigner
                    </p>

                    <subsubsection name="Overview">
                        <p>
The time stamp server generates time stamp tokens and have the support for the following options:
                        </p>
                        <ul>
                            <li>Set of accepted policies</li>
                            <li>Set of accepted algorithms</li>
                            <li>Set of accepted extensions</li>
                            <li>Accuracy microseconds</li>
                            <li>Accuracy milliseconds</li>
                            <li>Accuracy seconds</li>
                            <li>Included certificate chain (currently doesn't include CRLs)</li>
                            <li>Ordering</li>
                            <li>TSA name</li>
                        </ul>
                        <p>
The time stamp signer currently don't support:
                        </p>
                        <ul>
                            <li>CRL inclusion</li>
                            <li>Signed attributes</li>
                            <li>Unsigned attributes </li>
                        </ul>
                        <p>
Timestamps requests are served through a http service at the URL:
                        </p>
                        <pre>
'http://&lt;host name&gt;/signserver/process?workerId=&lt;worker Id&gt;'
                        </pre>
                        <p>
If no 'worker Id' parameter is specified then will the id of 1 be used as default.
                        </p>
                        <p>
The time-stamp signer requires a time-stamp certificate with the extended key usage 'time-stamp' only. The extended key usage extension must be critical.
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
The following properties can be configured with the signer:
                        </p>
                        <p>
<b>TIMESOURCE</b> = property containing the fully qualified name of the class implementing  the ITimeSource that should be used (OPTIONAL). Below are the built-in TimeSourceS available:
                        </p>
                        <table>
<!-- LocalComputerTimeSource -->
                            <tr>
                                <td>
<b>org.signserver.server.LocalComputerTimeSource</b>
                                </td>
                            </tr>
                            <tr>
                                <td>
This is the default TimeSource and uses the time from the local computer and
always returns the time.
                                </td>
                            </tr>

<!-- StatusReadingLocalComputerTimeSource -->
                            <tr>
                                <td>
<b>org.signserver.server.StatusReadingLocalComputerTimeSource</b>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>
This TimeSource returns the time from the local computer but only if the status property <i>TIMESOURCE0_INSYNC</i> is not expired and returned as <i>true</i> from the Status Repository.
                                    </p>
                                    <p>
Worker properties:
                                    </p>
                                    <ul>
                                        <li>
                                            <p>
                                                <b>LEAPSECOND_HANDLING</b>: NONE, PAUSE or STOP. Default is NONE.
                                            </p>
                                            <p>
<i>NONE</i>: Leap seconds are not considered and time-stamp tokens are issued as usual. 
                                            </p>
                                            <p>
<i>PAUSE</i>: The TimeSource will query the status property <i>LEAPSECOND</i> from the Status Repository.
If this property is not expired, and has the value <i>POSITIVE</i> or <i>NEGATIVE</i> and current time is in the interval surrounding a potential leap second (23:59:58,989 - 00:00:01,010) (at month shifts, in UTC time),
the TimeSource will make a pause to ensure the time value is not fetch on the leap second.
The value <i>NONE</i> is interpreted as there is no leap second and the time value will be returned immediately as usual.
If the value has expired, no valid time will be returned.
                                            </p>
                                            <p>
<i>STOP</i> The TimeSource will query the status property in the same way as for the PAUSE strategy. During the interval surrounding a potential leap second no time will be returned. This will cause the response to the clients to be timeSourceNotAvailable.
If the LEAPSECOND status property value has expired, no valid time will be returned.
                                            </p>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                        </table>
                        
                        <p>
<b>SIGNATUREALGORITHM</b> = property specifying the algorithm used to sign the timestamp (default: SHA1withRSA)
						</p>
                        
                        <p>
<b>ACCEPTEDALGORITHMS</b> = A ';' separated string containing accepted algorithms, can be null if it shouldn't be used. (OPTIONAL, Strongly recommended)
Supported Algorithms are: GOST3411, MD5, SHA1, SHA224, SHA256, SHA384, SHA512, RIPEMD128, RIPEMD160, RIPEMD256
                        </p>
                        <p>
<b>ACCEPTEDPOLICIES</b> =  A ';' separated string containing accepted policies, can be null if it shouldn't be used. (OPTIONAL, Recommended)
                        </p>
                        <p>
<b>ACCEPTEDEXTENSIONS</b> = A ';' separated string containing accepted extensions, can be null if it shouldn't be used. (OPTIONAL)
                        </p>
                        <p>
<b>DEFAULTTSAPOLICYOID</b> = The default policy ID of the time stamp authority (REQUIRED, if no policy OID is specified in the request then will this value be used.)
                        </p>
                        <p>
<b>ACCURACYMICROS</b> = Accuracy in micro seconds, Only decimal number format, only one of the accuracy properties should be set (OPTIONAL)
                        </p>
                        <p>
<b>ACCURACYMILLIS</b> = Accuracy in milliseconds, Only decimal number format, only one of the accuracy properties should be set (OPTIONAL)
                        </p>
                        <p>
<b>ACCURACYSECONDS</b> = Accuracy in seconds. Only decimal number format, only one of the accuracy properties should be set (OPTIONAL)
                        </p>
                        <p>
<b>ORDERING</b> = The ordering (OPTIONAL), default false. Only false is supported.
                        </p>
                        <p>
<b>TSA</b> = General name of the Time Stamp Authority. (OPTIONAL)
                        </p>
                        <p>
<b>REQUIREVALIDCHAIN</b> = Set to true to perform an extra check that the SIGNERCERTCHAIN only contains certificates in the chain of the signer certificate. (OPTIONAL), default false.
                        </p>
                        <p>
<b>MAXSERIALNUMBERLENGTH</b> = The maximum size (in bytes) used when generating serial numbers, must be between 8 and 20 (64 - 160 bits) (Default: 8)
The generated serial number will always be positive (so the sign bit is always a zero).
						</p>
                        <p>
<b>WORKERLOGGER</b> = As for other workers this property can be used to specify which worker logger to use. By default the <a href="complete.en.html#DefaultTimeStampLogger">DefaultTimeStampLogger</a> is used.
                        </p>
                    </subsubsection>
                    
                    <subsubsection name="TimeStampSigner Certificates">
                        <p>
Specifying a signer certificate is required as information from that certificate will be used to indicate which signer signed the time-stamp token.
                        </p>
                        <p>
The signer certificate chain contains all certificates included in the token  if the client requests the certificates.
The signer certificate MUST be included in the configured certificate chain.
Other certificates might also be included in the chain (typically intermediate CA certificates).
However, if REQUIREVALIDCHAIN=true is specified only the signer certificate directly followed by its issuer and then the issuer's issuer and so on is allowed. All certificates will be verified if there is a certificate coming after it. No check is made that the last certificate is a root certificate as that certificate is usually not included.
                        </p>
                    </subsubsection>
                </subsection>

				<subsection name="MS Authenticode Time Stamp Signer">
					<p>

The class name is: org.signserver.server.signers.tsa.MSAuthCodeTimeStampSigner
					</p>
					<subsubsection name="Overview">
						<p>
This time stamp signer is compatible with the Microsoft Authenticode time-stamping code signing.
                        </p>
					</subsubsection>
					<subsubsection name="Available Properties">
					    <p>
<b>TIMESOURCE</b> = property containing the fully qualified name of the class implementing  the ITimeSource that should be used (OPTIONAL).
This property has the same values as for TimeStampSigner <a href="complete.en.html#Available%20Properties">above</a>.
                        </p>
                        <p>
<b>SIGNATUREALGORITHM</b> = property specifying the algorithm used to sign the timestamp (default: SHA1withRSA)
						</p>
					</subsubsection>
					<subsubsection name="Howto">
						<p>
There is a howto about testing Authenticode signing available in <code>doc/howtos/test_ms_authcode.txt</code>
						</p>
					</subsubsection>
				</subsection>

                <subsection name="MRTD Signer">
                    <p>
The MRTD signer has the class name: org.signserver.server.signers.MRTDSigner
                    </p>
                    <subsubsection name="Overview">
                        <p>
The MRTD Signer performs a RSA signing operation on incoming data. The data should already be padded. This signer i used to sign 'Machine Readable Travel Documents' i.e. electronic passports.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
No configuration properties exists.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="PDF Signer">
                    <p>
The PDF signer has the class name: org.signserver.module.PDFSigner
                    </p>

                    <subsubsection name="Overview">
                        <p>
The main purpose of the PDF signer is to add digital signatures to PDF documents. 
                        </p>
                        
                        <p>
The signer supports the addition of visible or invisible signatures. Both visible and invisible signatures serve the same purpose of signing document, and technically are equivalent in that sense. The difference is that when visible signature  is applied to a document, signature image (in shape of rectangle) is placed at the specified place in the document, clicking on which will allow seeing properties of the signature (Adobe Acrobat Reader). On the other hand when invisible signature is applied, signature properties are accessed through menu items. For visible signatures properties such as : custom signature image, signature rectangle, page at which signature rectangle to be drawn and others can be specified (see Available Properties below)
                        </p>
                        <p>
PDF Signer can also apply timestamp to a signature. If the signature is timestamped, it can be viewable through signature properties in Adobe Acrobat Reader. Timestamping is used to prove that  document was signed before the time specified by timestamp token. If the signature is not timestamped then the signature time specified in the signature properties is not considered to be trusted. It is strongly advised to apply timestamp to a signature, and the TSA module can be used for this purpose.
                        </p>
                        <p>
Also CRL or OCSP Response of the signer's certificate can be embedded inside the signature package. Embedding CRL or OCSP response with the package will help validate signature even after the signer's certificate is expired. (Though it will not totally guarantee the long term signature preservation. Topic of long term signature preservation for archival purposes is a large one and is discussed to be implemented in future versions of SignServer).
                        </p>
                        <p>
The PDF Signer can also be configured to enforce that certain PDF permissions are not available in the signed document and/or that certain permissions should be removed.
                        </p>
                    </subsubsection>
                    
                    <subsubsection name="PDF passwords">
                        <p>
PDF documents can optionally be protected by a password.
                        </p>
                        <p>
There are two different types of passwords:
                            <ul>
                                <li>
                                    User password:<br/>
                                    Also sometimes referred to as "open password" or "document password". It can be used for reading an encrypted document.
                                </li>
                                <li>
                                    Owner password:<br/>
                                    Also sometimes referred to as "permission password" or "security restriction password". It can be used for reading an encrypted document and making changes to a document that has permissions.
                                </li>
                            </ul>
If a document is protected by an owner password it has to be supplied with the request for SignServer to sign the document. If the document is protected by a user password, either the user password or the owner password has to be supplied with the request for SignServer to sign the document.
                        </p>
                    </subsubsection>
                    
                    <subsubsection name="PDFSigner Requests">
                        <p>
PDF signing requests can be served using either web services or the web server interface (HTTP). See <a href="integration.html">Integration</a> for general information about the different interfaces.    
                        </p>
                        
                        <p>
For the web server interface the GenericProcessServlet can be used. The PDFSigner supports the extra request field "pdfPassword" letting the client supply a PDF password to be used for opening the PDF for signing (not required unless the PDF is already password protected).
                        </p>
                        <p>
For the old web services interface the request should contain an encoded GenericProcessesRequest and the response will be an GenericProcessResponse. It is possible to supply a PDF password by including it in the requestMetaData with the key "pdfPassword".
                        </p>
                    </subsubsection>

                    <subsubsection name="Worker Properties">
                        <p>
The following properties can be configured with the signer:
                        </p>
                        
                        <table>
                            <tr>
                                <td><b>REASON</b></td>
                                <td>
                                    <p>
The reason included in the PDF signature and displayed by the PDF reader. 
                                    </p>
                                    <p>
Default: "Signed by SignServer".
                                    </p>
                                </td>
                            </tr>
                                                                           
                            <tr>
                                <td><b>LOCATION</b></td>
                                <td>
                                    <p>
The location included in the PDF signature and displayed by the PDF reader. 
                                    </p>
                                    <p>
Default: "SignServer".
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <td><b>ADD_VISIBLE_SIGNATURE</b></td>
                                <td>
                                    <p>
Setting that control whether signature to be added should be visible or invisible.
                                    </p>
                                    <p>
Possible values: True or False.
                                    </p>
                                    <p>
Default: "False"                                        
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <td><b>VISIBLE_SIGNATURE_PAGE</b></td>
                                <td>
                                    <p>
Specifies the page on which the visible signature will be drawn. This property is ignored if ADD_VISIBLE_SIGNATURE is set to False.
                                    </p>
                                    <p>
Possible values:<br/>
"First" : signature drawn on first page of the document,<br/>
"Last"  : signature drawn on last page of the document,<br/>
page_number : signature is drawn on a page specified by numeric argument. If specified page number exceeds page count of the document ,signature is drawn on last page. If page_number specified is not numeric (or negative number) the signature will be drawn on first page
                                    </p>
                                    <p>
Default: "First".
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>                        
                                <td><b>VISIBLE_SIGNATURE_RECTANGLE</b></td>
                                <td>
                                    <p>
Specifies the rectangle signature is going to be drawn in. 
                                    </p>
                                    <p>
This property is ignored if ADD_VISIBLE_SIGNATURE is set to False. Format is : (llx,lly,urx,ury).<br/>
Here :<br/>
llx =left lower x coordinate,<br/>
lly=left lower y coordinate,<br/>
urx =upper right x coordinate,<br/>
ury = upper right y coordinate<br/>
                                    </p>
                                    <p>
Default: "400,700,500,800".
                                    </p>
                                </td>
	                        </tr>
                        
                            <tr>
                                <td><b>VISIBLE_SIGNATURE_CUSTOM_IMAGE_BASE64 &amp; VISIBLE_SIGNATURE_CUSTOM_IMAGE_PATH</b></td>
                                <td>
                                    <p>
	If we want the visible signature to contain custom image, specify image as base64 encoded byte array. Alternatively custom image can be specified by giving a path to image on file system.
                                    </p>
                                    <p>
Note: if specifying a path to an image "\" should be escaped (thus C:\photo.jpg => "C:\\photo.jpg")
                                    </p>
                                    <p>
Note: if specifying image as base64 encoded byte array "=" should be escaped (this "BBCXMI==" => "BBCXMI\=\=")
                                    </p>
                                    <p>
If both of these properties are set then VISIBLE_SIGNATURE_CUSTOM_IMAGE_BASE64 will take priority.
                                    </p>
                                    <p>
If we do not want this feature then do not set these properties.
                                    </p>
                                    <p>
Default: not set (no custom image).
                                    </p>
                                    <p>
These properties are ignored if ADD_VISIBLE_SIGNATURE is set to False.
                                    </p>
                                    <p>
NOTE: in clustered environment it is more manageable and advised to specify image as base64 string, since image data will be stored in central database. Otherwise each node should contain copy of the image, and each image managed separately (ex: on image updates, or insertion of new image for different worker)
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>VISIBLE_SIGNATURE_CUSTOM_IMAGE_SCALE_TO_RECTANGLE</b></td>
                                <td>
                                    <p>
	If we want our custom image to be resized to specified rectangle (set by VISIBLE_SIGNATURE_RECTANGLE) then set to True. If set to True image might look different that original (as an effect of resizing). If set to False the rectangle drawn will be resized to specified image's sizes.
                                    </p>
                                    <p>
If set to False llx and lly coordinates specified by VISIBLE_SIGNATURE_RECTANGLE property will be used for drawing rectangle (urx and ury will be calculated from specified image's size).
                                    </p>
                                    <p>
This property is ignored if ADD_VISIBLE_SIGNATURE is set to False or if custom image to use is not specified.
                                    </p>
                                    <p>
Possible values: True, False.
                                    </p>
                                    <p>
Default: "True".
                                    </p>
                                </td>
                            </tr>

                            <tr>
                                <td><b>CERTIFICATION_LEVEL</b></td>
                                <td>
                                    <p>
Set this property to have the document certified with a certifying signature.
                                    </p>
                                    <p>
Possible values:<br/>
NOT_CERTIFIED: The document is not certified.<br/>
FORM_FILLING: The document is certified but the form can be filled in without invalidating the signature.<br/>
FORM_FILLING_AND_ANNOTATIONS: The document is certified but the form can be filled in and annotations added without invalidating the signature.<br/>
NO_CHANGES_ALLOWED: The document is certified and no changes can be made.<br/>
                                    </p>
                                    <p>
Default: "NOT_CERTIFIED".
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <td><b>TSA_URL</b></td>
                                <td>
                                    <p>
If we want to timestamp document signature, specify timestamp authority URL.
                                    </p>
                                    <p>
If we do not want to timestamp document signature, do not set property.
                                    </p>
                                    <p>
Note: if path contains characters "\" or "=" , these characters should be escaped (thus "\" = "\\", "=" =>"\=")
                                    </p>
                                    <p>
Default: not set (no timestamping).
                                    </p>
                                </td>
                            </tr>

                            <tr>
	                                <td><b>TSA_USERNAME &amp; TSA_PASSWORD</b></td>
                                    <td>
                                        <p>
If the TSA requires authentication for timestamping, specify username and password. If the TSA does not require authentication, do not set these properties. These properties are ignored if TSA_URL is not set (no timestamping).
                                        </p>
                                        <p>
Default: not set (tsa does not require authentication).
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
	                                <td><b>EMBED_CRL</b></td>
                                    <td>
If we want to embed the CRL for signer certificate inside the signature package set to True, otherwise set to False.
                                        <p>
Default: "False".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
	                                <td><b>EMBED_OCSP_RESPONSE</b></td>
                                    <td>
                                        <p>
If we want to embed the OCSP response for the signer certificate inside the signature package set to True, otherwise set to False.
                                        </p>
                                        <p>
Note: issuer certificate (of signing certificate) should be in certificate chain.
                                        </p>
                                        <p>
Note: OCSP responses must contain a nextUpdate field in order for off-line validation to work with Adobe Reader. For EJBCA OCSP Responder see configuration of ocsp.untilNextUpdate in ocsp.properties.
                                        </p>
                                        <p>
Default: "False".
                                        </p>
                                    </td>
                            </tr>
                       
                            <tr>
                                    <td><b>ARCHIVETODISK</b></td>
                                    <td>
                                        <p>
If we want the produced signed document to be stored in the local file system set this property to true and add the ARCHIVETODISK_PATH_BASE property explained below.
                                        </p>
                                        <p>
Default: "False".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>ARCHIVETODISK_PATH_BASE</b></td>
                                    <td>
                                        <p>
The file path to the folder to store the signed documents in.
                                        </p>
                                        <p>
Required if ARCHIVETODISK is True.
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>ARCHIVETODISK_PATH_PATTERN</b></td>
                                    <td>
                                        <p>
Pattern used for creating sub-folders under the ARCHIVETODISK_PATH_BASE folder. 
                                        </p>
                                        <p>
Current date can be put in by adding ${DATE:yyyy} where yyyy can be replaced be the same syntax as defined in the class java.text.SimpleDateFormat. Other fields are:
                                        <ul>
                                            <li>${WORKERID}</li>
                                            <li>${WORKERNAME}</li>
                                            <li>${REMOTEIP}</li>
                                            <li>${REQUESTID}</li>
                                            <li>${TRANSACTIONID}</li>
                                            <li>${USERNAME}</li>
                                        </ul>
                                        </p>
                                        <p>
Default: "${DATE:yyyy/MM/dd}".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>ARCHIVETODISK_FILENAME_PATTERN</b></td>
                                    <td>
                                        <p>
Pattern used for creating the filename. The same fields and syntax as for the ARCHIVETODISK_PATH_PATTERN property can be used.
                                        </p>
                                        <p>
Default: "${WORKERID}-${REQUESTID}-${DATE:HHmmssSSS}.pdf".
                                        </p>
                                    </td>
                            </tr>
                        
                            <tr>
                                    <td><b>REFUSE_DOUBLE_INDIRECT_OBJECTS</b></td>
                                    <td>
                                        <p>
True if PDF documents containing multiple indirect objects with the same name should be refused. Used to mitigate a collision signature  vulnerability described in <a href="http://pdfsig-collision.florz.de/">http://pdfsig-collision.florz.de/</a>.
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>REJECT_PERMISSIONS</b></td>
                                    <td>
                                        <p>
Reject signing of the document if any of the permissions in the comma separated list would be in the document.
                                        </p>
                                        <p>
Available permissions (from the PDF reference, version 1.6, page 99, TABLE 3.20):
											<table cellspacing="1" cellpadding="4" class="ForrestTable">
												<tr>
													<td>ALLOW_PRINTING</td>
													<td>
Print the document to a representation
from which a faithful digital copy of the
PDF content could be generated. When
this is not set (and ALLOW_DEGRADED_PRINTING is set), printing
is limited to a low-level representation
of the appearance, possibly of
degraded quality.
													</td>
												</tr>
												<tr>
													<td>ALLOW_MODIFY_CONTENTS</td>
													<td>
Modify the contents of the document by
operations other than those controlled
by ALLOW_MODIFY_ANNOTATIONS, ALLOW_FILL_IN, and ALLOW_SCREENREADERS.
													
													</td>
												</tr>
												<tr>
													<td>ALLOW_COPY</td>
													<td>
Copy or otherwise extract text and
graphics from the document, including
extracting text and graphics (in support
of accessibility to users with disabilities
or for other purposes).
													</td>
												</tr>
												<tr>
													<td>ALLOW_MODIFY_ANNOTATIONS</td>
													<td>
Add or modify text annotations, fill in
interactive form fields, and, if ALLOW_MODIFY_CONTENTS is
also set, create or modify interactive
form fields (including signature fields).
													</td>
												</tr>
												<tr>
													<td>ALLOW_FILL_IN</td>
													<td>
Fill in existing interactive form fields
(including signature fields), even if ALLOW_MODIFY_ANNOTATIONS
is not set.
													</td>
												</tr>
												<tr>
													<td>ALLOW_SCREENREADERS</td>
													<td>
Extract text and graphics (in support of
accessibility to users with disabilities or
for other purposes).
													</td>
												</tr>
												<tr>
													<td>ALLOW_ASSEMBLY</td>
													<td>
Assemble the document (insert, rotate,
or delete pages and create bookmarks
or thumbnail images), even if ALLOW_MODIFY_CONTENTS is
not set.

													</td>
												</tr>
												<tr>
													<td>ALLOW_DEGRADED_PRINTING</td>
													<td>
Print the document (possibly not at the
high-est quality level, depending on
whether ALLOW_PRINTING is also set).
													</td>
												</tr>
											</table>
                                        </p>
                                        <p>
Default: unset/empty (no permissions are rejected)
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>SET_PERMISSIONS</b></td>
                                    <td>
                                        <p>
Replace the current permissions (if any) with the permissions specified in this comma separated list of permissions.
                                        </p>
                                        <p>
Available permissions: The same permission names as for the property REJECT_PERMISSIONS.    
                                        </p>
                                        <p>
This property can not be specified if REMOVE_PERMISSIONS is used.    
                                        </p>
                                        <p>
Notice 1: This property and the REMOVE_PERMISSIONS property only sets the permissions setting in the document. All permissions might not be enforced by the PDF reader and some permissions even though specified by this property to be allowed might not be allowed when opening the final document (i.e. if that would invalidate the signature and/or certification).
                                        </p>
                                        <p>
Notice 2: If the document is not already protected by an owner password and the SET_OWNERPASSWORD is not specified a random password will be used as owner password.    
                                        </p>
                                        <p>
Default: unset (permissions are not set by this property)
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>REMOVE_PERMISSIONS</b></td>
                                    <td>
                                        <p>
Remove all permissions specified in this comma separated list from the document.
                                        </p>
                                        <p>
Available permissions: The same permission names as for the property REJECT_PERMISSIONS.    
                                        </p>
                                        <p>
This property can not be specified if SET_PERMISSIONS is used.    
                                        </p>
                                        <p>
Notice: This property only removes the permissions listed even if some permissions (i.e. ALLOW_PRINTING) by the standard gives more permissions (i.e. also ALLOW_DEGRADED_PRINTING). To remove all permissions to print remove both ALLOW_PRINTING and ALLOW_DEGRADED_PRINTING. To still have ALLOW_DEGRADED_PRINTING it is possible to specify to only remove ALLOW_PRINTING.
                                        </p>
                                        <p>
See also Notice 1 and Notice 2 for REMOVE_PERMISSIONS which also applies to this setting.
                                        </p>
                                        <p>
Removing only ALLOW_DEGRADED_PRINTING has no effect as degraded printing is implicitly allowed if printing is allowed.    
                                        </p>
                                        <p>
Default: unset/empty (no permissions are removed)
                                        </p>
                                    </td>
                            </tr>
                            
                            <tr>
                                    <td><b>SET_OWNERPASSWORD</b></td>
                                    <td>
                                        <p>
Sets the specified password as owner password in the document.
                                        </p>
                                        <p>
The same permissions as before will be used (unless other properties will change them). The same encryption algorithm as the original document will be used. If the original document did not use any encryption then the default encryption algorithm will be used.    
                                        </p>
                                        <p>
Default: unset (if the permissions are changed, the existing owner password will be used or if no such password is used in the document a semi-random password will be created)
                                        </p>
                                    </td>
                            </tr>
                        </table>
                    </subsubsection>
                </subsection>

                <subsection name="ODF Signer">
                    <subsubsection name="Overview">
                        <p>
ODF Signer, which stands for Open Document Format Signer is a plug-in to SignServer that applies server side signature to documents in ODF format. It has been tested with OpenOffice.org 3.1.
                        </p>
                        <p>
	   ODF Signer supports only "invisible" signatures, that is unlike PDF signer there's no pictorial representation of the digital signature. When you open signed document in OpenOffice.org you can verify signature using toolbars, or the notifier in status bar (red mark), which notifies user that the document is digitally signed.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
	  Other than standard worker properties, ODF Signer does not have any other custom ODF signer specific properties.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="XML Signer">
                    <subsubsection name="Overview">
                        <p>
The XML Signer creates enveloped XML signatures using XMLDSig.
                        </p>
                        <p>
The signed XML document can be validated using the XML Validator.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
This signer has no extra properties above the standard worker properties.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="OOXML Signer">
                    <subsubsection name="Overview">
                        <p>
OOXML Signer, which stands for Office Open XML Signer is a plug-in to SignServer that applies server side signature to documents in OOXML format. It has been tested with MS Office 2007.
                        </p>
                        <p>
	   Currently OOXML Signer supports only "invisible" signatures , that is unlike PDF signer there's no pictorial representation of the digital signature. When you open signed document in MS Office you can verify signature using toolbars, or the notifier in status bar (red mark), which notifies user that the document is digitally signed.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
	  Other than standard worker properties, OOXML Signer does not have any other custom OOXML signer specific properties.
                        </p>
                        <p>
NOTE : In later versions of OOXML Signer it is planned to add support for visible signatures and custom signature image.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="CMS Signer">
                    <p>
The CMS signer has the fully qualified class name: org.signserver.module.cmssigner.CMSSigner
                    </p>
                    <subsubsection name="Overview">
                        <p>
The CMS signer can sign arbitrary data and produces a CMS (RFC 3852) SignedData
structure in binary format.
                        </p>
                        <p>
Currently the signed content is always embedded as well as the signer certificate.
                        </p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="SignServer Document Validators">
                <p>
Document Validators checks the signature and the certificate(s) in documents.
                </p>

                <subsection name="XML Validator">

                    <subsubsection name="Overview">
                        <p>
The XML validator validates the signature of XML documents. The certificate is checked by the configured certificate validation service.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p><b>VALIDATIONSERVICEWORKER</b> = Name or id of validation service worker for handling certificate validation</p>
                        <p><b>RETURNDOCUMENT</b> = True if the response should contain the validated document</p>
                        <p><b>STRIPSIGNATURE</b> = True if the signature should be removed from the document if it is returned</p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="SignServer Dispatchers">
                <p>
Dispatchers are workers that forwards the request to other workers.
                </p>

                <subsection name="FirstActiveDispatcher">

                    <p>
Fully qualified class name: org.signserver.server.dispatchers.FirstActiveDispatcher
                    </p>
                        
                    <subsubsection name="Overview">
                        <p>
Dispatches the request to the first of the configured workers that has an active
cryptotoken. This dispatcher can be useful if you want to have one worker to call
that forwards the request to any of the configured workers that has a valid
certificate etc.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p><b>WORKERS</b> = Comma separated list of workerNameS to try to forward requests to.</p>
                    </subsubsection>
                </subsection>
                
                <subsection name="RequestedPolicyDispatcher">
                    <p>
Fully qualified class name: org.signserver.module.tsa.RequestedPolicyDispatcher
                    </p>
                        
                    <subsubsection name="Overview">
                        <p>
Dispatches the Time-stamp request to an other signer based on the requested TSA Policy according to an configured mapping table.

This dispatcher can be useful if you want to have multiple signers (Time Stamp Units) signing with different TSA policies but don't want the client to have to call different workers.
                        </p>
                        <p>
See also the DispatchedAuthorizer which if configured by a signer can allow all requests that has gone through a Dispatcher.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p><b>DEFAULTWORKER</b> = Worker name or ID to dispatch to in case no policy was requested.</p>
                        <p><b>USEDEFAULTIFMISMATCH</b> = If true dispatches to DEFAULTWORKER in case no mapping existed for the requested policy OID (default: false)</p>
                        <p><b>MAPPINGS</b> = Mapping from requested policy OID to a worker name.
                        <br/>The property is of the form:
                        <br/>POLICYOID1:WORKERNAMEORID1; POLICYOID2:WORKERNAMEORID2; POLICYOID3:WORKERNAMEORID3;</p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="SignServer Validation Service Framework">
                <p>
The validation service framework is used to validate certificates from one or more issuers. It can be used to  have one central point of performing revokation statuses to simplify the integration of external PKIs within an enterprise.
                </p>
                <p>
The validation service framework also provides a validation cache that can be used to increase performance for those cases a application does multiple lookups of the same certificate within a short period of time.
                </p>
                <p>
Out-of-the-Box there exists a DefaultValidationService that should satisfy most use cases but it's possible to develop a custom ValidationService if necessary. See the developer section for more details.
                </p>
                <p>
All Validation Services is configured by specifying the org.signserver.validationservice.server.ValidationServiceWorker in the global configuration, then is the actual ValidationService configured in the worker configuration setting the class path in the property TYPE (Not necessary for the DefaultValidationService).
                </p>
                <p>
The validation service framework is mostly used with X509v3 certificates but other kinds of certificates is supported as well by design.
                </p>
                <p>
Another concept in the Validation Service Framework is that the client also can ask the service to check the type of certificate that the certificate might be used for. A certificate type could be IDENTIFICATION or ELECTRONIC SIGNATURE.
                </p>
                <subsection name="DefaultValidationService">
                    <subsubsection name="Overview">
                        <p>
The default validation service have a set of Validators. A validator is responsible to checking the validity against one or more issuers using for example CRL check or OCSP/XKMS lookup or just by checking some database. Currently there are no ready to use validators, these remain to be developed in future versions of the SignServer.
                        </p>
                        <p>
The Default Validation Service supports validations to be cached for some or all issuers for a specified amount of time.
                        </p>
                        <p>
If not configured otherwise will the validation service use the DefaultX509CertTypeChecker that determines the certificate type from the key usage in the certificate.  Key Encipherment and Digital Signature indicates a IDENTIFICATION type and Non-reputation indicates ELECTRONIC SIGNATURE.
                        </p>
                        <p>
There exists a validation specific WebService that can be used for platform independent client calls.
The WebService must be enabled during the build and isn't by default. The WebService WSDL file is located at the URL http://&lt;hostname&gt;:8080/signserver/validationws/validationws?wsdl and it contains two calls one is 'isValid' that performs the validation check and the other is a getStatus call that checks the health of the node and its underlying systems. The last calls can be used by clients for monitoring or implementing redundancy.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
The following properties can be configured with the default validation service:
                        </p>
                        <p>
The validation service have three types of properties, general properties (that applies for the service and all configured validators), validator properties (that only applies for a specific validator) and issuer properties (that only applies for an issuer configured in a specific validator).
                        </p>
                        <p>
<i>General Properties:</i><br/>
                        </p>
                        <p>
<b>CACHEDISSUERS</b> = A ';' separated list of issuer names (usually issuer DNs)  (Optional, no validation is cached if unset.)
                        </p>
                        <p>
<b>CERTTYPECHECKER</b> = Certificate type checker that should be used to determine the type of certificate (Optional, default is org.signserver.validationservice.server.DefaultX509CertTypeChecker)
                        </p>
                        <p>
<b>TIMEINCACHE</b> = Time in seconds a certificates validation should be cached (Optional, default is 10 seconds)
                        </p>
                        <p>
<i>Validator properties:</i><br/>
Validator properties is specified with the prefix of 'validator&lt;validatorId&gt;.' or 'val&lt;validatorId&gt;.' were validator Id should be an integer between 1 and 255. For instance, to specify the type of a validator with an id of 1 then specify 'val1.classpath=some.classpath.SomeClass'. This validator will be initialized with all its validator specific properties (with 'val&lt;id&gt;.' prefix removed) as well as the general ones.
                        </p>
                        <p>
<b>CLASSPATH</b> = Class path to the validator that should be used. (Required for each configured validator)
                        </p>
                        <p>
<i>Issuer properties:</i>  Issuer properties are specified as 'val&lt;val id&gt;.issuer&lt;issuer id&gt;.&lt;property&gt;' were issuer id is a positive integer between 1 and 255. All generic and validator specific properties (with the given validator id) will also be propagated to the specific issuer configuration.
                        </p>
                        <p>
<b>CERTCHAIN</b> = The certificate path of the CA certificates used to verify the certificate. Should be a appended BASE64 string. (Required for each configured issuer).
                        </p>
                        <p>
Here is an example configuration of a validation service to clarify things even further
                        </p>
                        <pre>
# Set up the worker -> validation service wrapper
GLOB.WORKER1.CLASSPATH= org.signserver.validationservice .server.ValidationServiceWorker
#Uncomment and set class path to custom validation service, othervise is default #used.
#WORKER1.TYPE=

# Name of Service (Optional)
WORKER1.NAME=ValidationService1

# Define TestCA2 and TestCA3 as a cached for 15 seconds, TestCA1 is Not cached.
WORKER1.CACHEDISSUERS=CN=TestCA2;CN=TestCA3
WORKER1.TIMEINCACHE=15

# Define a validator in charge of issuer TestCA1 and TestCA2
WORKER1.VAL1.CLASSPATH=&lt;Class path to some validator&gt;
WORKER1.VAL1.ISSUER1.CERTCHAIN=EFWAASDFADFASDFKASDKFW1231.....
WORKER1.VAL1.ISSUER2.CERTCHAIN=EFWAASDFADFASDFKASDKFW1231.....

# Define a validator in charge of issuer TestCA3
WORKER1.VAL2.CLASSPATH=&lt;Class path to some validator&gt;
WORKER1.VAL2.ISSUER1.CERTCHAIN=EFWAASDFADFASDFKASDKFW1231.....
                        </pre>
                    </subsubsection>
                </subsection>

                <subsection name="The Validation CLI interface.">
                    <p>
There exists a Java CLI tool that can be used to check the validity of a certificate from scripts. It supports a clustered SignServer installation by using the "Use first host that response OK" policy.
                    </p>
                    <p>
When compiling, make sure that setting validationclient.enabled is set to "true" in the build properties. The client is lib/SignServer-Client-ValidationCLI.jar.
                    </p>
                    <p>
Use the client with 'java -jar lib/SignServer-Client-ValidationCLI.jar &lt;options&gt;'.
                    </p>
                    <pre>
Here is a list of available options:

-cert &lt;cert-file&gt; 			: Path to certificate file (DER or PEM) (Required).
-certpurposes &lt;certpurposes&gt;  	: A ',' separated string containing requested certificate purposes.
-der                           			: Certificate is in DER format.
-help                          			: Display this info
-hosts &lt;hosts&gt;                 		: A ',' separated string containing the hostnames of the validation service nodes. Ex 'host1.someorg.org,host2.someorg.org' (Required)
-pem                    	       		: Certificate is in PEM format (Default).
-port &lt;port&gt;                   		: Remote port of service (Default is 8080 or 8442 for SSL).
-service &lt;service-name&gt;        	: The name or id of the validation service to process request. (Required)
-silent                        			: Don't produce any output, only return value.
-truststore &lt;jks-file&gt;         		: Path to JKS truststore containing trusted CA for SSL Server certificates.(for HTTPS connections)
-truststorepwd &lt;password&gt;      	: Password to unlock the truststore.


The following return values is used:

-2   : Error happened during execution
-1   : Bad arguments
0   : Certificate is valid
1   : Certificate is revoked
2   : Certificate is not yet valid
3   : Certificate have expired
4   : Certificate doesn't verify
5   : CA Certificate have been revoked
6   : CA Certificate is not yet valid
7   : CA Certificate have expired.
8   : Certificate have no valid certificate purpose.
                   </pre>

                </subsection>

                <subsection name="SignServer Group Key Service Framework">
                    <subsubsection name="Overview">
                        <p>
The group key service framework is used to manage and distribute group keys to clients in an organisation. The keys can be generated on demand or pre-generated at times when the system is not utilized a lot. The group keys can be both symmetric and asymmetric but one service can only distribute one type of key. If several kinds of keys are required should multiple services be set up within the same server.
                        </p>
                        <p>
The group keys are stored encrypted in database. The encryption key can be configured to be switched automatically after a defined number of encryptions to avoid overexposure of the cryptographic data. It is also possible to switch the encryption key manually.
                        </p>
                        <p>
The Framework requires an ExtendedCryptoToken, the difference are that the extended token have additional support for key export and symmetric key operations.
                        </p>
                        <p>
The Group Key Service have CLI commands for administration of the service such as pre-generate keys, manual switch of encryption key and removal of group keys.
                        </p>
                        <p>
The communication to the group key service is mainly done through the main Web Service interface. But other ways of communicating with the server might come in the future.
                        </p>
                        <p>
Authorization to group keys is very important and therefore should a special plug-in be developed  that looks up which clients that should have access to a specific group key which fit into the organisation needs. See the authorization chapter of how to develop a customized authorization plug-in.
                        </p>
                        <p>
The basic configuration of a group key service is very similar to that of a validation service. Two entries is required in the global configuration. The first is the class path for the Worker to GroupKeyService wrapper, then a class path reference to the extended crypto token used with the service. If not the default group key service should be used it is possible to define a custom one by specifying its class path in the TYPE worker property.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
<b>USEPREGENERATION</b> = Setting defining of keys should be pre-generated or generated on the fly when needed. If the pool of pre-generated keys gets empty will new keys always be generated automatically. (Optional, default is true)
                        </p>
                        <p>
<b>ENCKEYALG</b> =  Encryption algorithm used to encrypt the group keys stored in database. (Optional, default is "AES")
                        </p>
                        <p>
<b>ENCKEYSPEC</b> = Specification of the encryption key. (Optional, default is "256")
                        </p>
                        <p>
<b>GROUPKEYALG</b> =  Defines the type of group keys that this service should generate (Optional, default is "AES")
                        </p>
                        <p>
<b>GROUPKEYSPEC</b> = Specification of the generated group keys. (Optional, default is "256")
                        </p>
                        <p>
<b>KEYSWITCHTHRESHOLD</b> = Setting defining the number of group keys that should be  encrypted by the same encryption key before it's switched. (Optional, default is 100000)
                        </p>
                    </subsubsection>
                </subsection>
            </section>
            
            <section name="Timed Services">
                <p>
A Timed Service (formerly called just service) is a task that is run on a timely basis, performing maintenance tasks like changing active key, or it could generate a report.
                </p>
                <p>
A Timed Service framework supports a couple basic properties that is used to calculate when and how a timed service should run. These properties are:
                </p>
                <p>
<b>ACTIVE</b> =  "TRUE" if the service should be run, otherwise it is disabled.
                </p>
                <p>
<b>SINGLETON</b> =  "TRUE" if the service only should be run on one of the nodes in the cluster at the time. If it's not set or set to FALSE is the service run simultaneously on all nodes in the cluster. If the node running a singleton service fails will another node sense this and start up the service.
                </p>
                <p>
<b>INTERVAL</b> = Property defining the interval in seconds the service should run.
                </p>
                <p>
<b>INTERVALMS</b> = Property defining the interval in milliseconds the service
should run. Notice that the platform and application server might put a lower
bound on the value. The lower limit for GlassFish is by default 7000 milliseconds
but can be changed by editing minimum-delivery-interval-in-millis in domain.xml.
                </p>
                <p>
<b>CRON</b> = Property that should define a CRON expression of how often the service should run.  It should conform to Unix CRON standard. (One and only one of INTERVAL, INTERVALMS or CRON is required)
                </p>

                <subsection name="SignerStatusReportTimedService">
                    <p>
Fully qualified class name: org.signserver.module.signerstatusreport.SignerStatusReportTimedService
                    </p>
                    <subsubsection name="Overview">
                        <p>
The SignerStatusReportTimedService is a timed service that outputs status for a
set of workers to a file. The information includes each workers crypto token status
ACTIVE/OFFLINE and if available also the numbers of signatures that has been
performed with the key currently associated with the worker. If the worker has
a configured limit of number of signatures, this value is also included. See 
also the <a href="#SignerStatusReportWorker">SignerStatusReportWorker</a> which 
is an alternative way of offering this reports.
                        </p>
                        <p>
<b>Format:</b>
                        </p>
                        <pre>
workerName=WORKERNAME1, status=STATUS1, KEY3=VALUE3, KEY4=VALUE4, ...
workerName=WORKERNAME2, status=STATUS2, KEY3=VALUE3, KEY4=VALUE4, ...
workerName=WORKERNAME3, status=STATUS3, KEY3=VALUE3, KEY4=VALUE4, ...
...
                        </pre>
                        <p>
<b>Rules:</b>
<ul>
    <li>Each line contains a set of properties for one worker.</li>
    <li>Lines are separated by a system dependent newline character (CR,
LF or CRLF).</li>
    <li>Properties are of form KEY=VALUE and are separated by a comma and a
space (", ").</li>
    <li>The properties "workerName" and "status" are the only ones that must be
present.</li>
    <li>The property "workerName" is always the first property.</li>
</ul>
                        </p>
                        <p>
<b>Properties:</b>
<ul>
    <li><b>workerName</b>: name of the worker. Example: "sod71" or "sod72"</li>
    <li><b>status</b>: status of the worker's crypto token and key. Either
"ACTIVE" or "OFFLINE".</li>
    <li><b>validityNotBefore</b>: the first date the signer is allowed to sign.
Format is java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss z").</li>
    <li><b>validityNotAfter</b>: the last date the signer is allowed to sign.</li>
    <li><b>signings</b>: the number of signatures that has been performed with the key
used by this worker.</li>
    <li><b>signLimit</b>: the maximum number of signatures this worker is allowed
to perfom or -1 if there is no limit.</li>
</ul>
                        </p>
                        <p>
<b>Examples:</b>
                        </p>
                        <pre>
workerName=Sod71, status=ACTIVE, validityNotBefore=2010-07-05 17:32:36 CEST, validityNotAfter=2010-09-08 17:32:36 EEST, signings=132, signLimit=100000,
workerName=Sod72, status=OFFLINE, validityNotBefore=2010-07-05 17:32:33 CEST, validityNotAfter=2010-09-08 17:32:33 EEST, signings=100000, signLimit=100000,
workerName=Sod73, status=OFFLINE, validityNotBefore=2010-07-05 17:32:33 CEST, validityNotAfter=2010-09-08 17:32:33 EEST, signings=0, signLimit=100000,
workerName=Sod74, status=OFFLINE,
                        </pre>
                        <p>
<b>Examples explained:</b>
                        </p>
                        <p>
Sod71 has done 132 signings and is ACTIVE and validityNotAfter indicates
that it can continue to sign until 8th September if not the sign limit
is reached before
                        </p>
                        <p>
Sod72 has performed all of its 100000 signings and can not sign until it
gets a new key and certificate.
                        </p>
                        <p>
Sod73 has not reached its limit and is still in validity time but is
OFFLINE for some other reason.
                        </p>
                        <p>
Sod74 is OFFLINE and has no certificate configured.
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
<p><b>WORKERS</b> = Comma separated list of worker names (signers) that should
be monitored.</p>
<p><b>OUTPUTFILE</b> = File that the information will be written to. If the file
exists the content will be overwritten. The application server needs to have write
access to this file when the service is executed.

                        </p>
                    </subsubsection>
                    
                </subsection>
                <subsection name="Installing a service">
                    <p>To install a service you use the same commands as for installing a worker:</p>
                    <source>
$ bin/signserver setproperties configuration.properties
                    </source>
                    <p>Example:</p>
                    <source>
$ bin/signserver setproperties doc/sample-configs/qs_signerstatusreport_configuration.properties
===========================================
  Executing Command on host : localhost
===========================================
Configuring properties as defined in the file : doc/sample-configs/qs_signerstatusreport_configuration.properties
Setting the property ACTIVE to TRUE for worker 2
Setting the property INTERVAL to 10 for worker 2
Setting the global property WORKER2.CLASSPATH to org.signserver.server.timedservices.SignerStatusReportTimedService with scope GLOB.
Setting the property WORKERS to PDFSigner1 for worker 2
Setting the property NAME to SignerStatusReporter for worker 2
Setting the property OUTPUTFILE to /tmp/statusreport for worker 2

$ bin/signserver reload 2
===========================================
Executing Command on host : localhost
===========================================
SignServer reloaded successfully
Current configuration is now activated.
                    </source>
                </subsection>
            </section>

            <section name="Other workers">
                <subsection name="RenewalWorker">
                    
                    <subsubsection name="Overview">
                    <p>
The RenewalWorker can be used for generation a new key-pair and renewing a worker's certificate from EJBCA using web services (WS). The RenewalWorker should be configured with its own CryptoToken and an SSL client authentication certificate with permissions set up in EJBCA to issue certificates. Some properties are configured for the RenewalWorker such as the EJBCA WS endpoint URL and truststore details, other properties should be set on the worker that should be renewed (the renewee) and some arguments are provided when the worker is invoked.
                    </p>
                    <p>
Known limitation: It might not be possible to have multiple renewal workers using different crypto tokens because the keys and certificates used by the TLS connection for the web service is setup globally.
                    </p>
                    <p>
Fully qualified class name: <b>org.signserver.module.renewal.worker.RenewalWorker</b>
                    </p>
                    </subsubsection>
                    
                    <subsubsection name="Requesting the worker">
                    <p>
After setting up an RenewalWorker and installing its certificate signers (and other workers), can easily be renewed using the SignServer AdminGUI. See <a href="complete.en.html#Renew%20signer%20dialog">Renew Signer dialog</a>. As the RenewalWorker is a worker it can also be invoked using the normal client APIs. Using the demo web pages: <a href="http://localhost:8080/signserver/demo/genericsign.jsp">Generic Signing Demo</a>:
                    </p>
                    <p>
Sign by Direct Input<br/>
Worker name: MyRenewalWorker<br/>
Data:<br/>
                    </p>
                <source>
WORKER=MySigner
AUTHCODE=foo123</source>    
                    <p>
 Using the Client CLI:
                    </p><source>
bin/client.sh signdocument -workername MyRenewalWorker -data "WORKER=MySigner
AUTHCODE=foo123"</source>
                    <p>

(Notice that the command is on two lines)
                    </p>
                    </subsubsection>
                    
                    <subsubsection name="RenewalWorker operations">
                    <p>
The RenewalWorker starts by generating a new key-pair (unless an NEXTCERTSIGNKEY is already set for the renewee or the request property FORDEFAULTKEY=true is set in the request). The HSM/keystore password needs to be submitted as part of the request (AUTHCODE request property) to generate a new key-pair. After the key-pair has been generated and tested successfully the key alias is set as the NEXTCERTSIGNKEY property. A certificate signing request is created for the key and the worker sends the request to EJBCA to issue a certificate for the configured end entity. After receiving the certificate and certificate chain they are installed for the worker and the DEFAULTKEY property is updated with the value from NEXTCERTSIGNKEY and that property is removed.
                    </p>
                    </subsubsection>
                    
                    <subsubsection name="Worker Properties">
                        <p><b>EJBCAWSURL</b> = URL to the EJBCA. Example: https://ca-server:8443/ejbca</p>
                        <p><b>TRUSTSTOREPATH</b> = Path to the keystore containing the CA's SSL server certificate as a trusted entry.</p>
                        <p><b>TRUSTSTORETYPE</b> = Type of keystore. JKS and PEM is supported.</p>
                        <p><b>TRUSTSTOREPASSWORD</b> = Password protecting the truststore keystore.</p>
                    </subsubsection>
                    <subsubsection name="Properties of renewee">
                        <p><b>RENEWENDENTITY</b> = Name of the existing end entity in EJBCA</p>
                        <p><b>REQUESTDN</b> = Subject DN to set in the certificate signing request (PKCS#10).</p>
                        <p><b>SIGNATUREALGORITHM</b> = Signature algorithm to use when signing the certificate signing request (PKCS#10)</p>
                        <p><b>KEYALG</b> = Algorithm for the key generation. Examples: RSA, DSA or ECDSA</p>
                        <p><b>KEYSPEC</b> = Key length (for RSA or DSA) or curve name (for ECDSA). Examples: 2048, 4096, secp256r1</p>
                        <p><b>EXPLICITECC</b> = True if explicit domain parameters should be used instead of NamedCurves. Default: false</p>
                        <p><b>RENEWWORKER</b> = Name of the default RenewalWorker to use (Optional). Specify this to have the current RenewalWorker already selected in the AdminGUI when renewing signers.</p>
                        <p><b>DEFAULTKEY</b> = Key alias for the current existing key. The worker will update this property.</p>
                        <p><b>NEXTCERTSIGNKEY</b> = Key alias for the next existing key. If this property exists a new key-pair will not be generated. The worker will update/remove this property.</p>
                        
                    </subsubsection>
                    <subsubsection name="Request Properties">
                        <p><b>WORKER</b> = Name of the worker that should be renewed.</p>
                        <p><b>AUTHCODE</b> = HSM/keystore password for activation.</p>
                        <p><b>FORDEFAULTKEY</b> = If the current key should be used instead of the next key or a new key. (Optional, default: false)</p>
                    </subsubsection>
                    <subsubsection name="Response Properties">
                        <p><b>RESULT</b> = "OK" if the renewal succeeded otherwise "FAILURE".</p>
                        <p><b>MESSAGE</b> = Error message if any.</p>
                    </subsubsection>
                    <subsubsection name="Renewal modes">
                        <table>
                            <tr>
                                <th colspan="2">Renewee</th>
                                <th>Request</th>
                                <th colspan="2">Result</th>
                            </tr>
                            <tr>
                                <td><b>DEFAULTKEY</b></td>
                                <td><b>NEXTCERTSIGNKEY</b></td>
                                <td><b>FORDEFAULTKEY</b></td>
                                <td><b>DEFAULTKEY</b></td>
                                <td><b>NEXTCERTSIGNKEY</b></td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>New key and alias</td>
                                <td>Removed</td>
                            </tr>
                            <tr>
                                <td>present</td>
                                <td>-</td>
                                <td>-</td>
                                <td>New key and alias</td>
                                <td>Removed</td>
                            </tr>

                            <tr>
                                <td>-</td>
                                <td>present</td>
                                <td>-</td>
                                <td>Alias from nextcertsignkey</td>
                                <td>Removed</td>
                            </tr>
                            <tr>
                                <td>present</td>
                                <td>present</td>
                                <td>-</td>
                                <td>Alias from nextcertsignkey</td>
                                <td>Removed</td>
                            </tr>

                            <tr>
                                <td>present</td>
                                <td>-</td>
                                <td>TRUE</td>
                                <td>Same alias</td>
                                <td>Same alias</td>
                            </tr>
                            <tr>
                                <td>present</td>
                                <td>present</td>
                                <td>TRUE</td>
                                <td>Same alias</td>
                                <td>Same alias</td>
                            </tr>
                        </table>
                    </subsubsection>
                </subsection>
                
                <subsection name="StatusPropertiesWorker">
                    <p>
Fully qualified class name: org.signserver.module.statusproperties.StatusPropertiesWorker
                    </p>

                    <subsubsection name="Overview">
                        <p>
The StatusPropertiesWorker can be used to query and setting status properties in the status repository.
                        </p>
                    </subsubsection>
                    <subsubsection name="Worker Properties">
                        <p>(none)</p>
                    </subsubsection>
                    <subsubsection name="Request Properties">
                        <p><b>GET</b> - Comma-separated list of status properties to query</p>
                        <p><b>x.VALUE</b> - Where x is a status property: Sets the value of the property</p>
                        <p><b>x.EXPIRATION</b> - Where x is a status property: Sets the expiration time 
                            for x (x.VALUE must also be specified)</p>
                        <p>If no property is specified all valid status properties are returned</p>
                    </subsubsection>
                    <subsubsection name="Response Properties">
                        <p><b>x.VALUE</b> = See Request Properties</p>
                        <p><b>x.EXPIRATION</b> = See Request Properties</p>
                    </subsubsection>
                </subsection>
                
                                
                <subsection name="SignerStatusReportWorker">
                    <p>
Fully qualified class name: org.signserver.module.signerstatusreport.SignerStatusReportWorker
                    </p>

                    <subsubsection name="Overview">
                        <p>
The SignerStatusReportWorker is a worker that returns a status report for a configured 
set of workers. The information includes each workers crypto token status
ACTIVE/OFFLINE and if available also the numbers of signatures that has been
performed with the key currently associated with the worker. If the worker has
a configured limit of number of signatures, this value is also included. This 
worker returns the report in the same format as defined for the 
<a href="#SignerStatusReportTimedService">SignerStatusReportTimedService</a>.
                        </p>
                    </subsubsection>
                    <subsubsection name="Worker Properties">
                        <p><b>WORKERS</b> = Comma separated list of worker names (signers) that should
be monitored.</p>
                    </subsubsection>
                </subsection>
            </section>

            <section name="Available CryptoTokens">
                <p>
                    There exists four types of crypto tokens (Formerly known as sign tokens), two for storing the keys in software, one general for communicating with cryptographic hardware through the PKCS11 interface and one for SmartCards. See the developer section for information about developing support for other HSMs.
                </p>
                <p>
Which CryptoToken a worker is using is determined by the its SIGNERTOKEN.CLASSPATH
property which should contain the fully qualified class name of the CryptoToken
implementation. In addition to that property one must also make sure that the
other properties needed by the particular crypto token are available.
                </p>

                <subsection name="General properties">
                    <p>
<b>SIGNERTOKEN.CLASSPATH</b>: Fully qualified class name of the crypto token
implementation to use. See below for available crypto tokens.
                    </p>
                    <p>
<b>KEYALG</b>: Key algorithm to use when generating new keys (Only for
    cryptotokens supporting key generation).
                    </p>
                    <p>
<b>KEYSPEC</b>: Key specification to use when generating new keys (Only for
    cryptotokens supporting key generation).
                    </p>
                </subsection>

                <subsection name="P12CryptoToken">
                    <subsubsection name="Overview">
                        <p>
A CryptoToken using a PKCS#12 (.p12/.pfx) key-store in the local file-system. 
                        </p>
                        <p>
In a clustered environment the key store must placed at the same location at all nodes.
                        </p>
                        <p>
The P12CryptoToken, doesn't support the destroyKey() method
                        </p>
                    </subsubsection>

                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.JKSCryptoToken</b>
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
<b>KEYSTOREPATH</b>: The full path to the key-store file to load. (required)
                        </p>
                        <p>
<b>KEYSTOREPASSWORD</b>: The password that locks the key-store. Used for automatic activation.
                        </p>
                        <p>
<b>DEFAULTKEY</b>: The key to use. If not specified the first found key is used. (optional)
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="JKSCryptoToken">
                    <subsubsection name="Overview">
                        <p>
A CryptoToken using a Java Key Store (.jks) in the file-system.
                        </p>
                        <p>
In a clustered environment must the key store be at the same location at all nodes.
                        </p>
                        <p>
The JKSCryptoToken, doesn't support the destroyKey() method
                        </p>
                    </subsubsection>

                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.P12CryptoToken</b>
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
<b>KEYSTOREPATH</b>: The full path to the key-store to load. (required)
                        </p>
                        <p>
<b>KEYSTOREPASSWORD</b>: The password that locks the key-store. Used for automatic activation.
                        </p>
                        <p>
<b>DEFAULTKEY</b>: The key to use. If not specified the first found key is used. (optional)
                        </p>
                        <p>
<b>NEXTCERTSIGNKEY</b>: The next key to use. See PKCS11CryptoToken. (optional)
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="PrimeCardHSMCryptoToken">
                    <subsubsection name="Overview">
                        <p>
Using PrimeCardHSM it's possible to use a SmartCard to generate 2048-bit RSA signatures. The SmartCard can perform about one signature a second. PrimeCardHSM is proprietary software by PrimeKey Solutions AB.
                        </p>
                        <p>
PrimeCardHSM requires PCSCD software and SmartCard drivers. See separate documentation about installing PrimeCardHSM.
                        </p>
                        <p>
The PrimeCardHSMCryptoToken, doesn't support the destroyKey() method.
                        </p>
                    </subsubsection>

                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.PrimeCardHSMCryptoToken</b>
                        </p>
                    </subsubsection>

                    <subsubsection name="Available Properties">
                        <p>
<b>DEFAULTKEY</b> =   Hash value of the signing key on the card. See PrimeCardHSM documentation for more information.(Required)
                        </p>
                                                <p>
<b>NEXTCERTSIGNKEY</b>: The next key to use. See PKCS11CryptoToken. (optional)
                        </p>
                        <p>
<b>AUTHCODE</b> = Authentication code for automatic activation (Optional).
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="PKCS11CryptoToken">
                    <subsubsection name="Overview">
                        <p>
Using PKCS11 it's possible to use a HSM that has a PKCS11 module, such as Utimaco, nCipher, SafeNet or AEP KeyPer. SignServer uses the same underlying implementation of
PKCS11 crypto tokens as EJBCA. To find out more about supported devices and get information how to configure them you can visit the HSM documentation at <a href="http://ejbca.org/adminguide.html#Hardware%20Security%20Modules%20%28HSM%29">EJBCA.org</a>. 
The only thing that differs are the token labels strings, which you should use from below for SignServer. A very useful tool from EJBCA is the <a href="http://ejbca.org/userguide.html#EJBCA%20client%20toolbox">ClientToolBox</a>. 
If you can generate anbd test PKCS11 keys using the clientToolBox, you can use them with SignServer.
                        </p>
                    </subsubsection>
                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.PKCS11CryptoToken</b>
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
<b>DEFAULTKEY</b> =   The key alias. (Required)
                        </p>
                        <p>
<b>NEXTCERTSIGNKEY</b> = The next key to use. This property can be used to hold
the name of the next key to use. Certificate signing requests (CSR) can be made
for this key can while to the current key (DEFAULTKEY) is still in production.
After uploading the new certificate the value of NEXTCERTSIGNKEY can be moved to
DEFAULTKEY. (optional)
                        </p>
                        <p>
<b>PIN</b> =   Authentication code for activation. (Only required for auth-activation, otherwise the activatecryptotoken CLI command can be used)
                        </p>
                        <p>
<b>SHAREDLIBRARY</b> =   Full path to the library containing the PKCS11 interface. (Required)
                        </p>
                        <p>
<b>SLOT</b> or <b>SLOTLISTINDEX</b> =   Slot number or the index of the slot to use. (Required and only one of them can be used.)
                        </p>
                        <p>
<b>ATTRIBUTESFILE</b> = Path to file with PKCS#11 attributes used for key generation.
                        </p>
                        <p>
Sample p11attributes.cfg working with SafeNet Luna:
                        </p>
                        <pre>
attributes(generate,*,*) = {
  CKA_TOKEN = true
}
attributes(generate,CKO_PUBLIC_KEY,*) = {
  CKA_ENCRYPT = true
  CKA_VERIFY = true
  CKA_WRAP = true
}
attributes(generate, CKO_PRIVATE_KEY,*) = {
  CKA_EXTRACTABLE = false
  CKA_DECRYPT = true
  CKA_SIGN = true
  CKA_UNWRAP = true
}
                        </pre>
                    </subsubsection>
                    <subsubsection name="Example usage">
                        <p>
Edit qs_pdfsigner_configuration.properties and choose the sign token setting for the PKCS11 sign token. Run the following command to set up a PDF signer using the PKCS11 properties configured:
bin/signserver setproperties qs_pdfsigner_configuration.properties
                        </p>
                        <p>
Generate a keypair for the signer:
bin/signserver generatekey 8 -alias defaultKey -keyalg RSA -keyspec 2048
                        </p>
                        <p>
Test the keypair:
bin/signserver testkey 8
                        </p>
                        <p>
You also need a certificate for the signer. Generate a certificate request with the command:
bin/signserver generatecertreq 8 "CN=PKCS11 Signer token" SHA1WithRSA /tmp/certreq.pem
                        </p>
                        <p>
Add a user in EJBCA with a certificate profile suitable for signing, and enrol for a "Server Certificate" using the public web pages.
                        </p>
                        <p>
Create the certificate chain file with the command:
cat /tmp/cert.pem /tmp/AdminCA1.pem > /tmp/certchain.pem
                        </p>
                        <p>
The signer certificate must be first, and the root CA certificate last.
                        </p>
                        <p>
Upload the signing certificate chain to the signer using the command:
bin/signserver uploadsignercertificatechain 8 GLOB /tmp/certchain.pem
                        </p>
                        <p>
After the certificate chain has been uploaded to the server, the configuration must be reloaded and the server must be restarted. It is not sufficient to only reload the configuration.
                        </p>
                    </subsubsection>
                </subsection>

                <subsection name="SoftCryptoToken">
                    <subsubsection name="Overview">
                        <p>
The SoftCryptoToken is a simple token managing it's own soft keys instead of using a PKCS12 file. It can be used for test and demonstration purposes. The keys are stored in the worker's properties and is generated when genCertificateRequest is called. One key is used for all purposes and a new key is generated for every certificate request.
                        </p>
                        <p>
The method destroyKey is not supported.
                        </p>
                        <p>
There is also a tool available for constructing the properties from a PKCS12 file
in CryptoTokenUtils.java. To run the tool outside the IDE first build SignServer
by running "ant". After that the tool can be executed with something similar
to:
                        </p>
                        <pre>
java -cp lib/signserver-ejb.jar:lib/ext/1.6/bcprov-jdk.jar:lib/SignServer-Common.jar:lib/ext/ejbca-util.jar org.signserver.server.cryptotokens.CryptoTokenUtils createsoft src/test/dss10/dss10_signer1.p12 "signer 1" foo123
                        </pre>
                    </subsubsection>
                    <subsubsection name="SIGNERTOKEN.CLASSPATH">
                        <p>
The fully qualified class name is: <b>org.signserver.server.cryptotokens.SoftCryptoToken</b>
                        </p>
                    </subsubsection>
                    <subsubsection name="Available Properties">
                        <p>
<b>KEYDATA</b> =   The serialized KeyPair generated by genCertificateRequest, usually is this setting configured by the SoftCryptoToken itself.
                        </p>
                        <p>
<b>KEYALG</b> = The algorithm used when generating new keys. (Optional, default is "RSA")
                        </p>
                        <p>
<b>KEYSPEC</b> =   The key specification used when generating new keys. (Optional, default is "2048")
                        </p>
                    </subsubsection>
                    <subsubsection name="Example usage">
                        <p>
First change the global property of WORKER&lt;ID&gt;.CRYPTOTOKEN.CLASSPATH of the worker you want to use the SoftCryptoToken with. After reload will an empty and inactive SoftCryptoToken be created.
                        </p>
                        <p>
Then generate a certificate request with the command, in this step will new keys be generated
                        </p>
                        <pre>
bin/signserver generatecertreq &lt;id&gt; "CN=Soft Signer token" SHA1WithRSA /tmp/certreq.pem
                        </pre>
                        <p>
Then upload the signing certificate  to the worker using the command:
                        </p>
                        <pre>
bin/signserver uploadsignercertificatechain &lt;id&gt; GLOB /tmp/cert.pem
                        </pre>
                        <p>
After the certificate chain has been uploaded to the server, the configuration must be reloaded and the SoftCryptoToken will be active and ready to use.
                        </p>
                    </subsubsection>
                </subsection>
            </section>
            
            <section name="Archivers">
                <p>
See also the section about the <a href="complete.en.html#Archiving%20Responses">ARCHIVERS</a> worker property that can be set to one or more of the available Archiver implementations described below.
                </p>
                <subsection name="OldDatabaseArchiver">
                    <p>
The default archiver used if the the property ARCHIVE=true is set. Or if the ARCHIVERS property contains its class name. This Archiver archives to the database table "ArchiveData" using the same datasource as SignServer uses for accessing the database for its configuration etc.
                    </p>
                    <p>
The data is stored in an XML encoded Base64PutHashMap. In the "dataEncoding" column this format is indicated as DATA_ENCODING_XML.
                    </p>
                    <p>
The fully qualified class name is: <b>org.signserver.server.archive.olddbarchiver.OldDatabaseArchiver</b>
                    </p>
                    
                    <subsubsection name="Worker Properties">
                        <p>
<b>ARCHIVERx.ARCHIVE_OF_TYPE</b> = Where "x" is the index of the Archiver in the ARCHIVERS property. Determines what this Archiver should archive. Alternatives are: "REQUEST", "RESPONSE" or "REQUEST_AND_RESPONSE". Default is "RESPONSE".<br/>
Example: ARCHIVER0.ARCHIVE_OF_TYPE=REQUEST_AND_RESPONSE
                        </p>
                        <p>
Currently archiving of requests is only supported by TimeStampSigner and MSAuthCodeTimeStampSigner.
                        </p>
                        <p>
<b>ARCHIVERx.USE_FORWARDED_ADDRESS</b> = Where "x" is the index of the Archiver in the ARCHIVERS property.
If this property is set to "true", the last IP address in the comma-separated list given in the X-Forwarded-For header is used as the remote IP stored
in the archive in case this header is set. If the header is not included, the IP address the request comes from is used (the same behavior as when
this property isn't set, or set to "false"). This is useful when running a proxy in front of SignServer, to record the orginal IP address of the client,
instead of the proxy's IP address. Defaults to "false".
                        </p>
                    </subsubsection>
                    
                    <subsubsection name="ArchiveData table">
                        <p>
The exact database table structure is described in the SQL scripts available under doc/sql-scripts/.                            
                        </p>
                        <table border="1">
                            <tr>
                                <td>uniqueId</td>
                                <td>Primary key of the archive row.</td>
                            </tr>
                            <tr>
                                <td>archiveData</td>
                                <td>The actual data encoded in an Base64PutHashMap.</td>
                            </tr>
                            <tr>
                                <td>archiveId</td>
                                <td>
Some identifier for the produced item.<br/>
For the TimeStampSigner this would be the Time stamp token serial number (in hex encoding). Other signers might use a hash of the request document and the transaction ID.
                                </td>
                            </tr>
                            <tr>
                                <td>requestCertSerialnumber</td>
                                <td>
Serial number (in hex encoding) of the client certificate (if any) used by the client.<br/>
Notice: This only indicates that the client certificate where used when establishing the connection to the web server and not wither the worker required a client certificate or not or if it did any additional checks if the authenticated client was authorized.
                                </td>
                            </tr>
                            <tr>
                                <td>requestIP</td>
                                <td>
IP address of the host connecting to SignServer.<br/>
Currently X-FORWARDED-FOR headers are not considered.
                                </td>
                            </tr>
                            <tr>
                                <td>requestIssuerDN</td>
                                <td>
Issuer DN (in string representation) of the issuer of the client certificate (if any) used by the client.<br/>
See also note about requestCertSerialnumber.
                                </td>
                            </tr>
                            <tr>
                                <td>signerId</td>
                                <td>
ID of the worker handling the request.
                                </td>
                            </tr>
                            <tr>
                                <td>time</td>
                                <td>
Timestamp (number of milliseconds since January 1 1970 00:00:00) on the SignServer host when the item where archived.
                                </td>
                            </tr>
                            <tr>
                                <td>type</td>
                                <td>
The type of archivable item. Currently this could be:
                                    <ul>
                                        <li>0 - TYPE_RESPONSE</li>
                                        <li>1 - TYPE_REQUEST</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>dataEncoding</td>
                                <td>
Type of encoding used for the archiveData. Currently this could be:
                                    <ul>
                                        <li>NULL - DATA_ENCODING_XML</li>
                                        <li>0 - DATA_ENCODING_XML</li>
                                        <li>1 - DATA_ENCODING_BASE64</li>
                                    </ul>
Where DATA_ENCODING_XML uses the Base64PutHashMap and DATA_ENCODING_BASE64 uses a plain Base64 encoding of the binary data.
                                </td>
                            </tr>
                        </table>
                    </subsubsection>
                </subsection>
                
                <subsection name="Base64DatabaseArchiver">
                    <p>
This Archiver archives to the database table "ArchiveData" using the same datasource as SignServer uses for accessing the database for its configuration etc. It is similar to the OldDatabaseArchiver but does not use an XML structure for storing the data. Instead the data is simply base64 encoded.
                    </p>
                    <p>
In the "dataEncoding" column this format is indicated as DATA_ENCODING_BASE64.    
                    </p>
                    <p>
The fully qualified class name is: <b>org.signserver.server.archive.base64dbarchiver.Base64DatabaseArchiver</b>
                    </p>
                    
                    <subsubsection name="Worker Properties">
                        <p>
<b>ARCHIVERx.ARCHIVE_OF_TYPE</b> = Same as for OldDatabaseArchiver above.
                        </p>
                    </subsubsection>
                    
                </subsection>
                
            </section>
        </chapter>

        <chapter name="Development" shortname="development">
            <p>
This section describes the details of how to develop your own plug-ins for the SignServer API. It goes through most of the necessary interfaces to get going.
            </p>
            <p>
See also doc/DEVELOP.txt.                
            </p>
            
            <section name="Custom modules">
                <p>
Custom code can be included in the SignServer build process by placing the projects under the modules directory and adhere to the modules contract.    
                </p>
                <p>
First, the property modules.build.includes in res/modules-project.properties defines which projects that should be included in the build process. All projects with a folder name starting with SignServer-Module-*, SignServer-ejb* or SignServer-war are included. Other patterns can be included by setting a property extra.modules.build.includes.
                </p>
                <p>
Second, in the project folder there should be an Ant script called build.xml.    
                </p>
                <p>
Third, if the project should be called it should define the properties:
                    <ul>
                        <li><b>modulename</b>: The name of the module. Will be used as prefix to the enable-property. Example: module.pdfsigner (the enable property will then be module.pdfsigner.enabled)</li>
                        <li><b>clean.available</b>: True if the "clean" target should be called when the rest of SignServer is getting cleaned.</li>
                        <li><b>dist-module.available</b>: True if the "dist-module" target should be called when SignServer is getting built</li>
                    </ul>
                    Example:
                </p>
                <pre>
&lt;property name="modulename" value="module.pdfsigner"/&gt;
&lt;property name="clean.available" value="true"/&gt;
&lt;property name="dist-module.available" value="true"/&gt;    
                </pre>
                <p>
Forth, the dist-module target should take care of moving all distributables to the ../../lib directory and if the module should be deployed as part of the signserver.ear file a module descriptor should be placed in ../../mods-available. The name of the descriptor file should be priority_modulename.properties where priority is the order in which the module should be built and modulename is the name as defined by the property with the same name.
                </p>
                <p>
The priorities are basically like this:
                    <ul>
                        <li>10: Essential core modules (like signserverejb and signservercommon)</li>
                        <li>20: Other core modules (like web services)</li>
                        <li>30: Other core modules (like web components etc)</li>
                        <li>40: Other modules (like signers/validators etc)</li>
                    </ul>
                </p>
                <p>
The module descriptor can contain:
                    <ul>
                        <li>module.name: Same as the modulename property</li>
                        <li>module.type: The type of the module. "lib" if the module should be put in signserver.ear/lib, "ejb" if it is an EJB module or "war" if it is and WAR module.</li>
                        <li>to.root: Comma separated list of files to move to the root of signserver.ear. Basedir is SIGNSERVER_HOME and all files should be taken from lib/ (not modules/ as it is not available in the binary distribution).</li>
                        <li>to.lib: Same as to.root but for jar files to be moved to signserver.ear/lib/.</li>
                        <li>module.ejb: Only if module.type is "ear" or "war". The name of the enterprise module file (example: signserver.war).</li>
                        <li>module.web.web-uri: Only if module.type is "war". The name to put in the web-uri part of the application.xml for this enterprise module.</li>
                        <li>module.web.context-root: Only if module.type is "war". The name to put in the context-root part of the application.xml for this enterprise module.</li>
                        <li>postprocess.files: Optionally. Comma separated list of property name prefixes for each file to postprocess (example: postprocess.file1)</li>
                        <li>postprocess.file1.src: Only if postprocess.files specified. Path of file to postprocess (relative to SIGNSERVER_HOME/lib/, example: SignServer-ejb-SignServerWS.jar)</li>
                        <li>postprocess.file1.includes: Only if postprocess.files. Ant includes pattern with files in the jar to postprocess (example: META-INF/ejb-jar.xml)</li>
                        <li>postprocess.file1.dest: Only if postprocess.files specified. Location to put the resulting JAR in the final EAR. Default "" (the root) but should be set to "lib/" for library JARs.</li>
                    </ul>
                    Example (mods-available/40_module.pdfsigner.properties):
                </p>
                <pre>
module.name=module.pdfsigner
module.type=lib
to.root=
to.lib=lib/ext/1.6/bcprov-jdk.jar,lib/ext/1.6/bctsp-jdk.jar,lib/ext/cert-cvc.jar,lib/ext/commons-collections-3.2.jar,lib/ext/commons-io-1.4.jar,lib/ext/commons-lang-2.5.jar,lib/ext/commons-logging.jar,lib/ext/ejbca-util.jar,lib/ext/log4j.jar,lib/ext/module/pdfsigner/itext/itext.jar,lib/SignServer-Common.jar,lib/SignServer-ejb-interfaces.jar,lib/SignServer-Module-PDFSigner.jar
                </pre>
                <p>
                Example (mods-available/20_signserverws.properties):    
                </p>
                <pre>
module.name=signserverws
module.type=ejb
module.ejb=SignServer-ejb-SignServerWS.jar
to.root=lib/SignServer-ejb-SignServerWS.jar
to.lib=lib/ext/1.6/bcprov-jdk.jar,lib/ext/1.6/bctsp-jdk.jar,lib/ext/cert-cvc.jar,lib/ext/commons-collections-3.2.jar,lib/ext/commons-io-1.4.jar,lib/ext/commons-lang-2.5.jar,lib/ext/commons-logging.jar,lib/ext/ejbca-util.jar,lib/ext/log4j.jar,lib/SignServer-Common.jar,lib/SignServer-ejb-interfaces.jar
postprocess.files=postprocess.file1
postprocess.file1.src=SignServer-ejb-SignServerWS.jar
postprocess.file1.includes=META-INF/ejb-jar.xml
                </pre>
            
            </section>
                    
           <section name="Custom CLI">
               <p>
The SignServer AdminCLI or ClientCLI can be extended by putting additional JAR files with custom implementations of the ClientCommandFactory or AdminCommandFactory interfaces on the classpath. The implementation classes should be listed in the JAR files under META-INF/services in a file with the full class name of the interface. See SignServer-Client-ValidationCLI as an example. 
                </p>
            </section>
            <section name="Plugin development">
                <p>
The main component in the SignServer is the Worker from which most other components inherits. To get a better overview of how the different component types relate to one and another see illustration 1 in the Overview section.
                </p>
                <p>
Most workers work in the same way but with different interfaces to implement but for all of them should the following steps be performed.
                </p>
                <ul>
                    <li>
Create a custom  class implementing the specified interface. There usually exists a base class implementing the most basic function to simply the implementation even further. If it exists it's recommended to inherit it.
                    </li>
                    <li>
You can define your own properties that the worker can use for its configuration.
                    </li>
                    <li>
Make sure the custom class is available to the application server
                    </li>
                    <li>
Redeploy the SignServer.
                    </li>
                    <li>
Register the worker in the application by setting a property WORKER&lt;id&gt;.CLASSPATH with a global scope in the global configuration. (Also make sure to set it's crypto tokens class-path, see separate section).
                    </li>
                    <li>
Reload the service with the CLI reload command.
                    </li>
                </ul>
                <subsection name="Implementing Workers">
                    <subsubsection name="The ISigner Interface">
                        <p>
A Signer is a component used to perform some form of cryptographic processing of requested data and to create a custom signer class it should  implement the org.signserver.server.signers.ISigner interface. There exists a BaseSigner that can be inherited taking care of some of the functionality. If the BaseSigner is inherited the only method that needs to be implemented is 'processData() '.
                        </p>
                        <p>
There exists a DummySigner implementation that is used for demonstration purposes.
                        </p>
                    </subsubsection>

                    <subsubsection name="The ITimedService Interface">
                        <p>
There are two kinds of timed services, singleton or non-singleton. A singleton service is only run at one of the nodes at the time while non-singleton services are run at all nodes simultaneously. If a singleton service fails to run on one of the nodes will one of the other nodes take over the service
automatically.
                        </p>
                        <p>
If a service should be singleton or not is determined by a standard property SINGLETON defined
in the ServiceConfig class.
                        </p>
                        <p>
Other basic properties used to configure all services are:
ACTIVE when set to "TRUE" means that the service is active and should be run.
INTERVAL defining the interval in seconds of how often the service should be run.
INTERVALMS defining the interval in milliseconds of how often the service should be run.
CRON used instead of INTERVAL or INTERVALMS to specify on a calendar basis.
                        </p>
                        <p>
To create a custom timed service class it should implement the org.signserver.server.timedservices.ITimedService interface. There exists a BaseTimedService that can be inherited taking care of most of the basic functionality. If the BaseTimedService is inherited the the only method that needs to be implemented is the 'work()' method.
                        </p>
                        <p>
The work method that needs to be implemented is described here:
                        </p>
                        <pre>
/**
 * Method that should do the actual work and should
 * be implemented by all services. The method is run
 * at a periodical interval defined in getNextInterval.
 *
 * @throws ServiceExecutionFailedException if execution of a service failed
 */
public void work() throws ServiceExecutionFailedException;
                        </pre>
                        <p>
There exists a DummyTimedService implementation that is used for demonstration purposes.
                        </p>
                    </subsubsection>

                    <subsubsection name="IValidationService Interface">
                        <p>
Just as the other worker plug-ins have the validator service a base class taking care of most of the common methods and the only method that needs to be implemented is the 'validate' method below. But for most applications should the DefaultValidationService work. What is probably more interesting is to develop a custom IValidator used to integrate the default validation service against different certificate status repositories. See section called 'Other Customizations' for details of how to implement a Validator.
                        </p>
                        <pre>
/**
 * Method used to check the validation of a certificate
 *
 * @param validationRequest
 * @return a ValidateResponse
 * @throws IllegalRequestException if data in the request didn't conform with the specification.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during validation
 * @see org.signserver.validationservice.common.ValidateRequest
 * @see org.signserver.validationservice.common.ValidateResponse
 */
ValidateResponse validate(ValidateRequest validationRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;
                        </pre>
                    </subsubsection>

                    <subsubsection name="IGroupKeyService Interface">
                        <p>
To customize a group key service is slightly more work. Then need five methods be implemented: 'fetchGroupKey', 'pregenerateGroupKeys', 'swithEncryptionKey', 'removeGroupKeys' and 'getStatus'. The default implementation stores the group keys in database with a reference to the encryption key used, the encryption key is stored in the extended key store. See the JavaDoc and the code for the default group key service for more details of implementing a customized one.
                        </p>
                        <pre>
/**
 * Main method of a Group Key Service responsible for fetching keys from
 * the database.
 *
 * @param fetchKeyRequest
 * @return a FetchKeyReponse
 * @throws IllegalRequestException if data in the request didn't conform with the specification.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.FetchKeyRequest
 * @see org.signserver.groupkeyservice.common.FetchKeyResponse
 */
FetchKeyResponse fetchGroupKey(FetchKeyRequest fetchKeyRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;

/**
 * Method that instructs the group key service to pregenerate keys.
 * This method is called at periods when the server is having
 * a low load. This option is optional to implement, if the
 * service doesn't support this method it should return null.
 *
 *
 * @param pregenerateKeysRequest request data
 * @return a response containing number of keys generated, etc
 * @throws IllegalRequestException if requests contain unsupported data.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.PregenerateKeysRequest
 * @see org.signserver.groupkeyservice.common.PregenerateKeysResponse
 */
PregenerateKeysResponse pregenerateGroupKeys(PregenerateKeysRequest pregenerateKeysRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;


/**
 * Method instructing the key service to switch the encryption key for
 * storing the group keys in the database. This to ensure that one encryption
 * key isn't exposed through to much data.
 *
 * This method is optional for the implementing service to implement, if
 * it's not implemented it should return null.
 *
 * @param switchEncKeyRequest request data.
 * @return a response containing the result of the operation such as new key index.
 * @throws IllegalRequestException if requests contain unsupported data.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException  for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.SwitchEncKeyRequest
 * @see org.signserver.groupkeyservice.common.SwitchEncKeyResponse
 */
SwitchEncKeyResponse switchEncryptionKey(SwitchEncKeyRequest switchEncKeyRequest) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;

/**
 * Method instructing the key service to remove old group keys not used anymore
 * it up to the caller to check that the implementing service supports the type
 * of IRemoveGroupKeyRequest used. The request should contain data specifying which
 * keys that should be removed.
 *
 * This method is optional for the implementing service to implement, if
 * it's not implemented it should return null.
 *
 * @param removeGroupKeyRequests request data.
 * @return a response containing the result of the operation such as number of keys actually removed.
 * @throws IllegalRequestException if requests contain unsupported data.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException  for general failure exception during key generation.
 * @see org.signserver.groupkeyservice.common.RemoveGroupKeyResponse
 * @see org.signserver.groupkeyservice.common.IRemoveGroupKeyRequest
 */
RemoveGroupKeyResponse removeGroupKeys(IRemoveGroupKeyRequest removeGroupKeyRequests) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;


/**
 * Should return the actual status of the worker, status could be if
 * the signer is activated or not, or equivalent for a service.
 * @return a WorkerStatus object.
 */
public WorkerStatus getStatus();
                        </pre>
                    </subsubsection>
                </subsection>

                <subsection name="Implementing Crypto Tokens">
                    <subsubsection name="The ICryptoToken Interface">
                        <ul>
                            <li>
A custom crypto token needs to implement the interface org.signserver.server.cryptotokens.ICryptoToken.  See P12CryptoToken for an example implementation.
                            </li>
                            <li>
You can define own properties for a crypto token in the same way as for workers. The properties are sent to the crypto token upon initialization.
                            </li>
                            <li>
Make sure the custom class is available to the application server
                            </li>
                            <li>
Redeploy the SignServer.
                            </li>
                            <li>
Register the crypto token to a worker in the application by setting a property WORKER&lt;id&gt;.CRYPTOTOKEN.CLASSPATH with a global scope in the global configuration. (Also make sure to set it's crypto tokens class-path, see next section).
                            </li>
                            <li>
Reload the service with the CLI reload command.
                            </li>
                        </ul>
                        <p>
The ICryptoToken interface have the following methods that needs to be implemented:
                        </p>
                        <pre>
public interface ICryptoToken {
	public static final int PURPOSE_SIGN = 1;
	public static final int PURPOSE_DECRYPT = 2;

	public static final int PROVIDERUSAGE_SIGN    = 1;
	public static final int PROVIDERUSAGE_DECRYPT = 2;

   /**
    * Method called after creation of instance.
    *
    */
	public abstract void init(Properties props) throws CryptoTokenInitializationFailureException;

	/**
	 *  Method that returns the current status of the crypto token.
	 *
	 *  Should return one of the SignerStatus.STATUS_.. values
	 */
	public abstract int getCryptoTokenStatus();

    /**
     * Method used to activate SignTokens when connected after being off-line.
     *
     * @param authenticationcode used to unlock crypto token, i.e PIN for smartcard HSMs
     * @throws CryptoTokenOfflineException if SignToken is not available or connected.
     * @throws CryptoTokenAuthenticationFailureException with error message if authentication to crypto token fail.
     */
    public abstract void activate(String authenticationcode) throws CryptoTokenAuthenticationFailureException, CryptoTokenOfflineException;

    /**
     * Method used to deactivate crypto tokens.
     * Used to set a crypto token too off-line status and to reset the HSMs authorization code.
     *
     * @return true if deactivation was successful.
     */
    public abstract boolean deactivate();

    /** Returns the private key (if possible) of token.
    *
    * @param purpose should one of the PURPOSE_... constants
    * @throws CryptoTokenOfflineException if CryptoToken is not available or connected.
    * @return PrivateKey object
    */
    public abstract PrivateKey getPrivateKey(int purpose) throws CryptoTokenOfflineException;

    /** Returns the public key (if possible) of token.
    *
    * @param purpose should one of the PURPOSE_... constants
    * @throws CryptoTokenOfflineException if CryptoToken is not available or connected.
    * @return PublicKey object
    */
    public abstract PublicKey getPublicKey(int purpose) throws CryptoTokenOfflineException;


    /** Returns the signature Provider that should be used to sign things with
     *  the PrivateKey object returned by this crypto device implementation.
     *  @param providerUsage should be one if the ICryptoToken.PROVIDERUSAGE_ constants
     *  specifying the usage of the private key.
     * @return String the name of the Provider
     */
    public abstract String getProvider(int providerUsage);

    /**
     * Method returning the crypto tokens certificate if it's included in the token.
     * This method should only be implemented by soft crypto tokens which have the certificate
     * included in the key store.
     *
     * All other crypto tokens should return 'null' and let the signer fetch the certificate from database.
     *
     */

    public abstract Certificate getCertificate(int purpose) throws CryptoTokenOfflineException;


    /**
     * Method returning the crypto tokens certificate chain if it's included in the token.
     * This method should only be implemented by soft crypto tokens which have the certificates
     * included in the key store.
     *
     * All other crypto tokens should return 'null' and let the signer fetch the certificate from database.
     *
     */

    public abstract Collection&lt;Certificate&gt; getCertificateChain(int purpose) throws CryptoTokenOfflineException;

	/**
	 * Method used to tell the crypto token to create a certificate request using its crypto token.
	 */
	public ICertReqData genCertificateRequest(ISignerCertReqInfo info) throws CryptoTokenOfflineException;

	/**
	 * Method used to remove a key in the signer that shouldn't be used any more
	 * @param purpose on of ICryptoToken.PURPOSE_ constants
	 * @return true if removal was successful.
	 */
	public boolean destroyKey(int purpose);
}
                        </pre>
                    </subsubsection>

                    <subsubsection name="The Extended Crypto Token Interface">
                        <p>
The default group key service need support for symmetric keys in addition the the functionality provided in the basic crypto token which mainly focuses on asymmetric key functionality.
                        </p>
                        <p>
The extended crypto token adds four more methods that need implementation used to generate exportable keys (symmetric or asymmetric) and to encrypt/decrypt data using symmetric keys.
                        </p>
                        <pre>
public interface IExtendedCryptoToken extends ICryptoToken {

	/**
	 * Method instructing the crypto token to generate a key that is returned
	 *
	 * @param keyAlg the key algorithm to generate, it's up to the caller to check that the crypto token
	 * used supports the given value.
	 * @param keySpec specification of the key, it's up to the caller to check that the crypto token
	 * used supports the given value.
	 * @return either a java.security.Key or a java.security.KeyPair depending on type of keyAlg sent to the the crypto token.
	 * @throws IllegalRequestException if the token doesn't support the given key alg or key spec.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	Serializable genExportableKey(String keyAlg, String keySpec) throws IllegalRequestException, CryptoTokenOfflineException;

	/**
	 * Instructs the crypto token to generate a key stored in the device returning only
	 * a alias reference to the key.
	 *
	 * @param keyAlg the key algorithm to generate, it's up to the caller to check that the crypto token
	 * @param keySpec keySpec specification of the key, it's up to the caller to check that the crypto token
	 * used supports the given value.
	 * @return a reference to the key in that can be used later for encryption/decryption.
	 *
	 * @throws IllegalRequestException if the token doesn't support the given key alg or key spec.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	String genNonExportableKey(String keyAlg, String keySpec) throws IllegalRequestException,  CryptoTokenOfflineException;

	/**
	 * Method used to encrypt data using a key stored in the crypto token. This
	 * method should mainly be used for symmetric encryption.
	 * @param keyRef a alias reference to the key that should be used.
	 * @param data the data to encrypt.
	 * @return the encrypted data.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	byte[] encryptData(String keyRef, byte[] data) throws CryptoTokenOfflineException;

	/**
	 * Method used to decrypt data using a key stored in the crypto token. This
	 * method should mainly be used for symmetric encryption.
	 * @param keyRef a alias reference to the key that should be used.
	 * @param data the data to decrypt.
	 * @return the encrypted data.
	 * @throws CryptoTokenOfflineException if the token isn't online.
	 */
	byte[] decryptData(String keyRef, byte[] data) throws CryptoTokenOfflineException;


}
                        </pre>
                    </subsubsection>
                </subsection>
            </section>

            <section name="Other Customizations">
                <subsection name="The IValidator Interface">
                    <p>
A Validator is used in the DefaultValidationService to connect to different kinds of certificate status repositories, such as CRL, OCSP, XKMS, database etc. It contains two methods 'validate' used for the actual certificate validation and 'testConnection' used by health check related functionality to check that the connection to the underlying validator resource is alright.
                    </p>
                    <pre>
/**
 * Main method of a Validation Service responsible for validating certificates.
 *
 * Important a validator also have to support to check the revocation status of the
 * involved CA certificates and should only return Validation object with status REVOKED or VALID
 * If the validator doesn't support the given issuer it must return null.
 *
 *
 * @param cert the certificate to validate.
 * @return a Validation object or null if the certificate couldn't be looked up in this validator.
 * @throws IllegalRequestException if data in the request didn't conform with the specification.
 * @throws CryptoTokenOfflineException if the crypto token isn't online.
 * @throws SignServerException for general failure exception during validation.
 */
Validation validate(ICertificate cert) throws IllegalRequestException, CryptoTokenOfflineException, SignServerException;






/**
 * Optional method used to test the connection to a specific underlying validator implementation.
 *
 * @throws ConnectException if connection to underlying validator implementation failed.
 * @throws SignServerException for general failure exception during validation.
 */
void testConnection() throws ConnectException, SignServerException;
                    </pre>
                </subsection>

                <subsection name="The IAuthorizer Interface">
                    <p>
It's possible to integrate the authorization of processable requests with external authorizations applications. All that is needed is a class implementing the IAuthorizer interface containing two methods, 'init' and 'isAuthorized'.
                    </p>
                    <p>
To register that the customized authorizer should be used by a worker, all that's needed to be done is to set the property AUTHTYPE to the class path of the authorizer implementation.
                    </p>
                    <pre>
public interface IAuthorizer {

	/**
	 * Method called by the worker upon first call to the authenticator after instantiation.
	 *
	 * @param workerId id of worker.
	 * @param config active worker configuration of worker
	 * @param em the SignServer EntityManager
	 * @throws SignServerException if unexpected error occurred during initialization.
	 */
	void init(int workerId, WorkerConfig config, EntityManager em) throws SignServerException;

	/**
	 *
	 * Main method determining if the requester is authorized to process the data in the request.
	 *
	 * @param request the request data sent to the worker to process.
	 * @param requestContext containing the optional clientCert client certificate or remote IP of the user, may also contain customly defined data.
	 * @throws SignServerException if unexpected error occurred during authorization.
	 * @throws IllegalRequestException if the requester isn't authorized or couldn't be authenticated for some other reason.
	 */
	void isAuthorized(ProcessRequest request, RequestContext requestContext) throws IllegalRequestException, SignServerException;
}
                    </pre>
                </subsection>
                
                <subsection name="The Archiving API">
                    <p>
Custom ArchiverS can be implemented by implementing the Archiver interface. See 
org.signserver.server.archive.Archiver.
                    </p>
                    <p>
                        <a href="../images/archivingapi.png"><img src="../images/archivingapi.png" align="middle" border="1" width="603" height="323" alt="Archiving API"/></a>
                    </p>
                </subsection>

                <subsection name="Using the Global Configuration Store">
                    <p>
The global configuration store is a memory bank that workers can use to store data used
in ongoing operations. The data can be either node (i.e. only read by the current node) or global
scoped.
                    </p>
                    <p>
To access the global configuration store use the getGlobalConfigurationSession() method
from the BaseWorker (inherited by most of the base component implementations). The returned
GlobalConfigurationSession have the following methods that can be used (the other ones should be
avoided)
                    </p>
                    <pre>
/**
* Method setting a global configuration property. For node. prefix will the
node id be appended.
* @param scope, one of the GlobalConfiguration.SCOPE_ constants
* @param key of the property should not have any scope prefix, never null
* @param value the value, never null.
*/
public void setProperty( java.lang.String scope,java.lang.String
key,java.lang.String value ) ;
/**
* Method used to remove a property from the global configuration.
* @param scope, one of the GlobalConfiguration.SCOPE_ constants
* @param key of the property should start with either glob. or node., never
null
* @return true if removal was successful, othervise false.
*/
public boolean removeProperty( java.lang.String scope,java.lang.String key )
;
/**
* Method that returns all the global properties with Global Scope and Node
scopes properties for this node.
* @return A GlobalConfiguration Object, nevel null
*/
public org.signserver.common.GlobalConfiguration getGlobalConfiguration( ) ;
                    </pre>
                    <p>
The getGlobalConfiguration returns a GlobalConfiguration and have a method
String getProperty(String scope, String property) that can be used.

The value of the property can be user-defined as long as it is guaranteed to be unique over the entire
application.

Reserved values are all property keys starting with "WORKER".
                    </p>
                </subsection>
            </section>


            <section name="Testing">
                <p>
                    There exists some test scripts used to test that the SignServer functions correctly. They are described here.
                </p>

                <subsection name="Automatic JUnit Tests">
                    <p>
Automatic JUnit tests are in the different projects and system tests in SignServer-Test-System.
                    </p>
                    <p>
Important: For the SignServer test suite to run successful the following 
properties should be set in signserver_build.properties:
                    <ul>
                        <li>signserverws.enabled=true</li>
                        <li>genericws.enabled=true</li>
                        <li>validationws.enabled=true</li>
                        <li>adminws.enabled=true</li>
                        <li>timestampclient.enabled=true</li>
                        <li>validationclient.enabled=true</li>
                        <li>signingandvalidationapi.enabled=true</li>
                        <li>clientcli.enabled=true</li>
                        <li>includemodulesinbuild=true</li>
                        <li>useclusterclassloader=true</li>
                        <li>clusterclassloader.useclassversions=true</li>
                        <li>healthcheck.maintenancefile=/path/to/signserver/maintenance.properties (where /path/to/signserver is the path where SignServer is located)</li>
                    </ul>
                    </p>
                    <p>
For the Database CLI tests to run successfully you will need to put the JDBC 
driver for your database as lib/ext/jdbc/jdbc.jar.
                    </p>
                    <p>
To run the test suite do the following:
                    </p>
                    <ul>
<li>Set the environment variable SIGNSERVER_HOME</li>
<li>Make sure SignServer is deployed and the application server is running</li>
<li>Do 'ant test:run'</li>
<li>A protocol is generated in the directory 'bin/junit'</li>
                    </ul>
                    <p>
A single system test can be run with "ant test:runone -Dtest.runone=ClassName" 
where ClassName is replaced with the test class to run.
                    </p>
                    <p>
A single test can also be run the same way from any of the other projects that 
has tests by executing the command from their project directory.
                    </p>
                    <p>
If SignServer is configured to run without database some tests needs to be excluded by running like this:    
                    </p>
                    <source>
bin/ant test:run -Dexcludes="**/ArchivingCLITest*,**/GroupKeyServiceCLITest*,**/Base64DatabaseArchiverTest*,**/OldDatabaseArchiverTest*,,**/GroupKeyServiceTest*,**/ArchiveTest*,**/AuditLogCLITest*,**/DatabaseCLITest*"
                    </source>
                    
                    <subsubsection name="System tests with HSM">
                        <p>
To run system tests with an HSM create an properties file in SIGNSERVER_HOME called test-config.properties containing the PKCS#11 configuration including the key alias for an existing RSA key-pair:                            
                        </p>
                        <source>
test.p11.sharedlibrary=/opt/ETcpsdk/lib/linux-x86_64/libcryptoki.so
test.p11.slot=1
test.p11.pin=foo123
test.p11.existingkey1=mykey001
                        </source>
                        <p>
The tests can be run with:
                        </p>
                        <source>
ant test:p11:run test:report
                        </source>
                    </subsubsection>
                </subsection>
                
                <subsection name="Random testing">
                    <p>
SignServer-Test-Random is a tool for random testing of SignServer. Each test suite
has different requirements configured workers in the different worker groups and 
how many threads that can be used etc. See the source code for further details.
                    </p>
                    <subsubsection name="Building and running">
                        <p>
Build from modules/SignServer-Test-Random/ using:
                        </p>
                        <source>ant jar</source>
                        <p>
It can then be run from SIGNSERVER_HOME using:
                        </p>
                        <source>bin/randomtest</source>
                    </subsubsection>
                    
                    <subsubsection name="Usage">
                        <source>
usage: randomtest &lt;options&gt;
Random testing tool
 -randomseed &lt;arg&gt;     Optional. Seed to initialize the pseudo random
                       generator with.
 -testsuite &lt;arg&gt;      Test suite to run. Any of [signWhileUpdatingConfig,
                       signAndCountSignings, signWhileRenewing].
 -threadgroup1 &lt;arg&gt;   Number of threads in group 1.
 -threadgroup2 &lt;arg&gt;   Number of threads in group 2.
 -timelimit &lt;arg&gt;      Optional. Only run for the specified time (in
                       milliseconds).
 -workergroup1 &lt;arg&gt;   First group of workers. Comma separated list of
                       workerId/workerType.
 -workergroup2 &lt;arg&gt;   Second group of workers. Comma separated list of
                       workerId/workerType
 -workergroup3 &lt;arg&gt;   Third group of workers. Comma separated list of
                       workerId/workerType

Sample usages:
a) randomtest -testsuite signWhileUpdatingConfig -workergroup1
5678/xml,5679/tsa,5680/xml -threadgroup1 4 -workergroup2
5677/xml,5678/xml,5679/tsa -threadgroup2 3 -timelimit 30000

b) randomtest -testsuite signAndCountSignings -workergroup1
5678/xml,5679/tsa,5680/xml -threadgroup1 10 -timelimit 30000

c) randomtest -testsuite signWhileRenewing -workergroup1 300/xml
-workergroup2 301/xml,302/xml -threadgroup1 5 -workergroup3 309/renew
-timelimit 20000

Available worker types:
- workerType can be any of [xml, tsa, renew]

Test suite: signAndCountSignings
- Signs documents with the workers from group 1 with the number of threads
defined for group 1
- Pauses signings and counts performed signings a compares to the key
usage counter value
- Notice that it is assumed that all workers use the same key-pair

Test suite: signWhileUpdatingConfig
- Signs documents with the workers from group 1 with the number of threads
defined for group 1
- Increases a counter in the configuration of group 2
- Notice that the size of thread group 2 must be equal to the number of
workers in group 2

Test suite: signWhileRenewing
- Signs documents with the workers from group 1 with the number of threads
defined for group 1
- Renews signers from group 2 using the one renewal worker in group 3
- Notice that group 3 should only include one renewal worker
                        </source>
                    </subsubsection>
                    
                </subsection>
                
                <subsection name="Stress testing">
                                    <p>
SignServer-Test-Performance is a tool for performance testing of SignServer. Currently it contains only one
test suite for testing time stamping. See the source code for further details.
                    </p>
                    <subsubsection name="Building and running">
                        <p>
Build from modules/SignServer-Test-Performance/ using:
                        </p>
                        <source>ant jar</source>
                        <p>
It can then be run from SIGNSERVER_HOME using:
                        </p>
                        <source>bin/stresstest</source>
                    </subsubsection>
                    
                    <subsubsection name="Usage">
                        <source>
usage: stresstest &lt;options&gt;
Performance testing tool
 -maxwaittime &lt;arg&gt;     Maximum number of milliseconds for a thread to
                        wait until issuing the next time stamp.
                        Default=100
 -statoutputdir &lt;arg&gt;   Optional. Directory to output statistics to. If
                        set, each threads creates a file in this directory
                        to output its response times to. The directory
                        must exist.
 -testsuite&lt;arg&gt;       Test suite to run. Any of [TimeStamp1].
 -threads &lt;arg&gt;         Number of threads requesting time stamps.
 -timelimit &lt;arg&gt;       Optional. Only run for the specified time (in
                        milliseconds).
 -tsaurl &lt;arg&gt;          URL to timestamp worker to use.
 -warmuptime &lt;arg&gt;      Don't count number of signings and response times
                        until after this time (in milliseconds). Default=0
                        (no warmup time).

Sample usages:
a) stresstest -testsuite TimeStamp1 -threads 4 -tsaurl
http://localhost:8080/signserver/tsa?workerId=1
b) stresstest -testsuite TimeStamp1 -threads 4 -maxwaittime 100
-statoutputdir ./statistics/ -tsaurl
http://localhost:8080/signserver/tsa?workerId=1
              			</source>
              			
              			<p>
              				When finished (after time limit expires, or process is stopped using control+c) a statistic
              				overview is printed containing number of signings, and statistics (average,
              				minimum, and maximum) for response times.
                                </p>
					</subsubsection>
                </subsection>
                
            </section>
        </chapter>

        <chapter name="Miscellaneous" shortname="misc">

            <section name="The Global Configuration Store">
                <p>
The available workers and its crypto tokens and services is configured in something called the global configuration store that is slightly different from a worker configuration.
                </p>
                <p>
Is is dynamically configured and activated immediately. I can contain any type of data (in string representation) and can be of two types, either with global scope or node scope. A Global scoped property can be accessed by  all nodes in the cluster while a Node scoped property in only used within a node and cannot be accessed by the other nodes.
                </p>
                <subsection name="SignServer specific">
                    <p>
Database failure is handled differently. If a node looses connection to the database it put itself in a state called 'unsynchronised' and will continue its operation without storing the data to database by using a cached global configuration. It is possible to later resynchronise one nodes cached global configuration data  with the database with a CLI command called 'resync'. But it is only possible to sync one of the nodes global configuration to the database.
                    </p>
                </subsection>
            </section>

            <section name="Status Repository">
                <p>
The status repository holds non-persistent local (per JVM) status information (properties) with optional expiration times. After the expiration time the property is not returned. The value is also not preserved among server restarts. 
                </p>
                <p>
This could be used by having workers read the status from the repository while an external (or internal) service periodically updates it. The (optional) expiration time on the values makes it possible to detect if an periodic service has failed to update the value within the specified time.
                </p>
                <p>
From the Admin CLI the status repository can be controlled using the <i>getstatusproperties</i>, <i>getstatusproperty</i> and <i>setstatusproperty</i> commands.
                </p>
            </section>

            <section name="Logging">
                <p>
SignServer uses Log4j for logging and there are a few different loggers
available where the first two can be useful for audit logging:
                </p>
                <ul>
                    <li>Worker Log (org.signserver.server.log.IWorkerLogger)</li>
                    <li>Debug Log (any other class name)</li>
                </ul>
                <subsection name="Worker Log">
                    <p>
The purpose of the Worker Loggers are to log each transaction handled by the
worker. Each worker can choose to have its own configuration for the logger. By
default the AllFieldsWorkerLogger is used which used logs all the available
fields one after each other separated by semi colons.
                    </p>
                    <p>
Which Worker Logger configuration to use is configured by setting the
<b>WORKERLOGGER</b> property to the full class name of the IWorkerLogger
implementation in the worker's configuration.
                    </p>
                    <subsubsection name="AllFieldsWorkerLogger">
                        <p>
The default worker logger for most workers. Can be used during testing to find 
which fields a worker logs and then changed to the PatternWorkerLogger with only 
does fields that are of interest chosen.<br/>
LOGLEVEL_DEFAULT sets the level at which
the logger will do log output. These are specified as standard Log4J levels
(FATAL, ERROR, WARNING, INFO, DEBUG, and TRACE), if not set, it defaults to INFO.
                        </p>
                        <source>
WORKERLOGGER=org.signserver.server.log.AllFieldsWorkerLogger
LOGLEVEL_DEFAULT=INFO
                        </source>
                    </subsubsection>
                    <subsubsection name="SecurityEventsWorkerLogger">
                        <p>
Worker logger using the CESeCore security events logger.
This logger included all fields in the additionalDetails fields in the audit log, except the worker ID, which is mapped to searchDetail2. 
                        </p>
                        <source>
WORKERLOGGER=org.signserver.server.log.SecurityEventsWorkerLogger
                        </source>
                    </subsubsection>
                    <subsubsection name="PatternWorkerLogger">
                    	<p>
The LOGLEVEL_DEFAULT property has the same behavior as for the AllFieldsWorkerLogger.
                    	</p>
                        <source>
WORKERLOGGER=org.signserver.server.log.PatternWorkerLogger
LOGTIMEZONE=GMT
LOGDATEFORMAT=yyyy-MM-dd:HH:mm:ss:z
LOGPATTERN=\$\{(.+?)\}
LOGORDER=AUDIT; LOG_ID: ${LOG_ID}; CLIENT_IP: ${CLIENT_IP}; REQUEST_FULLURL: ${REQUEST_FULLURL}; RequestTime: ${LOG_TIME}; ResponseTime: ${REPLY_TIME}; EXCEPTION: ${EXCEPTION};
LOGLEVEL_DEFAULT=INFO
                        </source>
                    </subsubsection>
                    <subsubsection name="DefaultTimeStampLogger">
                        <p>
Pattern logger with a default log order suitable for logging time-stamp requests. This logger is the default logger used by the <a href="complete.en.html#Time-stamp%20Signer">TimeStampSigner</a>.
                        </p>
                        <source>
WORKERLOGGER=org.signserver.module.tsa.DefaultTimeStampLogger
                        </source>
                    </subsubsection>
                    <subsubsection name="NullWorkerLogger">
                        <p>
Worker logger that does not log anything.    
                        </p>
                        <source>
WORKERLOGGER=org.signserver.server.log.NullWorkerLogger                            
                        </source>
                    </subsubsection>
                    <subsubsection name="CustomTimeStampLogger1">
                        <source>
WORKERLOGGER=org.signserver.module.tsa.CustomTimeStampLogger1
                        </source>
                    </subsubsection>
                    <subsubsection name="FileWorkerLogger">
                    	<p>
Worker logger that writes the log values to a worker-specific log file (the logger logs all fields, similar to
AllFieldsWorkerLogger.<br/>
This logger is mainly intended for use by unit tests, and is not thread safe.
						</p>
						<source>
WORKERLOGGER=org.signserver.server.log.FileWorkerLogger
LOG_FILE_PATH=/path/to/logfile
						</source>
					</subsubsection>
                </subsection>
                
                <subsection name="System Log">
                    <p>
The purpose of the system log is to log events concerning the SignServer application but not necessarily related to any signing transaction (that is covered by the Worker Log). The audit log covers key and certificate management events, status properties updates (for instance for the status of the time source) and to some extent also configuration changes. For details see the table of events below.<br/>
From version 3.4.0 SignServer uses the CESeCore library to perform audit logging.
An example configuration for CESeCore is provided in <code>conf/cesecore.properties.sample</code>.
The default logging implementation, <code>org.signserver.server.log.SignServerLog4jDevice</code> uses Log4J and a similar logging format as the old SystemLogger.
                    </p>
                    
                    <subsubsection name="Available log events">
                        <table border="1">
                            <tr>
                                <th colspan="2"><i>Services</i></th>
                            </tr>
                            <tr>
                                <td><b>SIGNSERVER_STARTUP</b></td>
                                <td>
                                    <p>
Logged at startup of the SignServer application.
                                    </p>
                                    <p>
<b>VERSION:</b> The version of SignServer.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: SIGNSERVER_STARTUP; MODULE: SERVICE; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; VERSION: SignServer 3.3.0alpha12; REPLY_TIME:1350562045545</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>SIGNSERVER_SHUTDOWN</b></td>
                                <td>
                                    <p>
Logged at shutdown of the SignServer application.
                                    </p>
                                    <p>
<b>VERSION:</b> The version of SignServer.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: SIGNSERVER_SHUTDOWN; MODULE: SERVICE; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; VERSION: SignServer 3.3.0alpha12; REPLY_TIME:1350562045545</pre>
                                    </p>
                                </td>
                            </tr>
                        
                            <tr>
                                <th colspan="2"><i>Global configuration</i></th>
                            </tr>
                            <tr>
                                <td><b>SET_GLOBAL_PROPERTY</b></td>
                                <td>
                                    <p>
Logged when a global configuration property was updated.
                                    </p>
                                    <p>
<b>GLOBALCONFIG_PROPERTY:</b> The property that was updated.<br/>
<b>GLOBALCONFIG_VALUE:</b> The new value of the property.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: SET_GLOBAL_PROPERTY; MODULE: GLOBAL_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; GLOBALCONFIG_VALUE: TESTVALUE47; GLOBALCONFIG_PROPERTY: GLOB.TESTPROPERTY47; REPLY_TIME:1350657202153</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>REMOVE_GLOBAL_PROPERTY</b></td>
                                <td>
                                    <p>
Logged when a global configuration property was removed.
                                    </p>
                                    <p>
<b>GLOBALCONFIG_PROPERTY:</b> The property that was removed.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: REMOVE_GLOBAL_PROPERTY; MODULE: GLOBAL_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; GLOBALCONFIG_PROPERTY: GLOB.TESTPROPERTY47; REPLY_TIME:1350657202444</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>GLOBAL_CONFIG_RELOAD</b></td>
                                <td>
                                    <p>
Logged when the global configuration was reloaded from the database.
                                    </p>
                                    <p>
Example:
<pre class="code">EVENT: GLOBAL_CONFIG_RELOAD; MODULE: GLOBAL_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; REPLY_TIME:1350657202593</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>GLOBAL_CONFIG_RESYNC</b></td>
                                <td>
                                    <p>
Logged when the resync command was executed.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: GLOBAL_CONFIG_RESYNC; MODULE: GLOBAL_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; REPLY_TIME:1350894343902</pre>
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <th colspan="2"><i>Worker configuration</i></th>
                            </tr>
                            <tr>
                                <td><b>SET_WORKER_CONFIG</b></td>
                                <td>
                                    <p>
Logged when a worker's configuration was updated by adding and/or removing and/or changing any values.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker.
                                    </p>
                                    <p>
Changes in worker properties are logged with prefixes <b>added/changed/removed</b> followed by a colon and the property name a colon and the property value.<br/>
Several property changes can occur in one log line (see examples below).<br/>
Authorized clients are shown as a property with the name <b>authorized_client</b>.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: SET_WORKER_CONFIG; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; added:FOO: bar; REPLY_TIME:1350657202773</pre>
                                    </p>
                                    <p>
<pre class="code">EVENT: SET_WORKER_CONFIG; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; changed:FOO: newvalue; REPLY_TIME:1350657202873</pre>
                                    </p>
                                    <p>
<pre class="code">EVENT: SET_WORKER_CONFIG; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; removed:FOO: newvalue; REPLY_TIME:1350657202873</pre>
                                    </p>
                                    <p>
<pre class="code">EVENT: SET_WORKER_CONFIG; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; added:FOO: bar; changed:BAR: newvalue; REPLY_TIME:1350657202873</pre>                                    
                                    </p>
                                    <p>
<pre class="code">EVENT: SET_WORKER_CONFIG; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; added:authorized_client: SN: 1234567890, issuer DN: CN=Test; REPLY_TIME:1350657202873</pre>
                                    </p>
                                    
                                </td>
                            </tr>
                            <tr>
                                <td><b>CERTINSTALLED</b></td>
                                <td>
                                    <p>
Logged when a certificate was uploaded to the worker configuration.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker.<br/>
<b>CERTIFICATE:</b> The certificate in PEM format.<br/>
<b>SCOPE: </b> If the setting was at GLOBAL or NODE scope.<br/>
<b>NODE: </b> The ID of the node if the setting was at NODE scope, otherwise not available.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: CERTINSTALLED; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; CERTIFICATE: Subject: CN=Anyone
Issuer: CN=Anyone
-----BEGIN CERTIFICATE-----
MIIBnTCCAQagAwIBAgIIWWNYSOeuN+swDQYJKoZIhvcNAQEFBQAwETEPMA0GA1UE
AwwGQW55b25lMB4XDTEyMTAxOTE0MzMyM1oXDTEzMTAxOTE0MzMyM1owETEPMA0G
A1UEAwwGQW55b25lMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCDE9GElbJd
e74WmIpPSsIF9r5vv0oH6WWo7n31goR1zMIHJPC9V1mpwQZ6C0uCHCV2ZvqQIIAE
ZQM7mgbPfxjCF74RqKzScZlOSaHnvdf7zCWpYraVrIDt9Wg3HMxye0/L3cCImmkY
FkFtabtoa5UuPZObdIt154Yg+GpGB8aPBwIDAQABMA0GCSqGSIb3DQEBBQUAA4GB
AHm3oAUHwM0KwMcEUwWouE0f4+UK6ZvYvxLAgiCVZQnPImcqX1oBl+iFV59FlsXj
rqoQYJROxIeV0ByGeyBYXqvgTw1YtdqoR+wKmiymjn/lynmTh1fQMcFoUouGfubX
EK4rfPBXEl33gKbsO5aeMHd5iF2jtx7RfYMsOuHKoDSe
-----END CERTIFICATE-----
; SCOPE: GLOBAL; REPLY_TIME:1350657204367</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>CERTCHAININSTALLED</b></td>
                                <td>
                                    <p>
Logged when a certificate chain was uploaded to the worker configuration.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker.<br/>
<b>CERTIFICATECHAIN:</b> The certificates in PEM format.<br/>
<b>SCOPE: </b> If the setting was at GLOBAL or NODE scope.<br/>
<b>NODE: </b> The ID of the node if the setting was at NODE scope, otherwise not available.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: CERTCHAININSTALLED; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; CERTIFICATECHAIN: Subject: CN=Signer,C=SE
Issuer: CN=Issuer,C=SE
-----BEGIN CERTIFICATE-----
MIIBdjCCASCgAwIBAgIIE+fXOs/SAwMwDQYJKoZIhvcNAQEFBQAwHjEPMA0GA1UE
AwwGSXNzdWVyMQswCQYDVQQGEwJTRTAeFw0xMjEwMjIwNzQ1MDZaFw0xMzEwMjIw
NzQ1MDZaMB4xDzANBgNVBAMMBlNpZ25lcjELMAkGA1UEBhMCU0UwgZ8wDQYJKoZI
hvcNAQEBBQADgY0AMIGJAoGBAKpX5psdaL5CHAKSxoOvB12Ie8iUb/mX6ikF8jfu
zrbwVgf6bX0RCUnD+v+t9vY7byz+nN32KnmGluNGdBFdM1Ug9Oc+64ZNBbgZi9mi
cHnKMDLLSECBY2Nux62PZejp5SwtzpjFymt3TMCtRr4UHGu3zkuqLLCHFlGRdvdo
MPQ9AgMBAAEwDQYJKoZIhvcNAQEFBQADQQADlInGm9AujZfL+1kM7ehaKyKKencF
fp6YGElOpGEplxxIwgmVc0iYKv4rCkfUAysYL6l3AC+VLK1asxkpEJc1
-----END CERTIFICATE-----
Subject: CN=Issuer,C=SE
Issuer: CN=Issuer,C=SE
-----BEGIN CERTIFICATE-----
MIIBMTCB3KADAgECAggbfKZHs8ttKDANBgkqhkiG9w0BAQUFADAeMQ8wDQYDVQQD
DAZJc3N1ZXIxCzAJBgNVBAYTAlNFMB4XDTEyMTAyMjA3NDUwNloXDTEzMTAyMjA3
NDUwNlowHjEPMA0GA1UEAwwGSXNzdWVyMQswCQYDVQQGEwJTRTBcMA0GCSqGSIb3
DQEBAQUAA0sAMEgCQQCpgzxJ6r6D1cP8v1AB88pJsCwi0SJdeRSGYydYYBOafJk0
fpqxJCwaiFS3tt9OkWUAXzcixv5+sItkEuEOpmp7AgMBAAEwDQYJKoZIhvcNAQEF
BQADQQCC5NG3eWx/mXXKZmePOvZEIwyqWHOwzsBB174gkzlyhOdiOr3YwVihyebI
VAfkEktRrO04Hi5eLR+AxW7EVz6l
-----END CERTIFICATE-----
; SCOPE: GLOBAL; REPLY_TIME:1350891906417
</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>KEYSELECTED</b></td>
                                <td>
                                    <p>
Logged when the key-pair to use was selected by changing the value of the DEFAULTKEY worker property.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker.<br/>
<b>KEYALIAS:</b> The new key alias.<br/>
<b>SCOPE: </b> If the setting was at GLOBAL or NODE scope.<br/>
<b>NODE: </b> The ID of the node if the setting was at NODE scope, otherwise not available.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: KEYSELECTED; MODULE: WORKER_CONFIG; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 100; KEYALIAS: ts_key00002; SCOPE: GLOBAL; REPLY_TIME:1350891907048</pre>
                                    </p>
                                </td>
                            </tr>

                            <tr>
                                <th colspan="2"><i>Key management</i></th>
                            </tr>
                            <tr>
                                <td><b>KEYGEN</b></td>
                                <td>
                                    <p>
Logged when a new key-pair was generated using the built-in key generation command.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker.<br/>
<b>KEYALIAS:</b> The new key alias.<br/>
<b>KEYSPEC:</b> The key specification (ie. RSA/DSA bit length or EC curve).<br/>
<b>KEYALG:</b> The key algorithm.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: KEYGEN; MODULE: KEY_MANAGEMENT; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 5676; KEYALIAS: ts_key00004; KEYSPEC: 2048; KEYALG: RSA; REPLY_TIME:135089190791</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>KEYTEST</b></td>
                                <td>
                                    <p>
Logged when the key test command was executed and a test signing with either the specified key or all keys in the slot if that was specified.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker.<br/>
<b>KEYALIAS:</b> Alias of the the key to test or "all" to test all available keys in the slot.<br/>
<b>TESTRESULTS:</b> The test report with an entry for each tested key.
                                    </p>
                                    <p>
Example:<br/>            
<pre class="code">EVENT: KEYTEST; MODULE: KEY_MANAGEMENT; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 47; KEYALIAS: all; TESTRESULTS: KeyTestResult{alias=tsu47_key00005, success=true, status=, publicKeyHash=979359e5261112b11fac341962bec1e7e6052d9e}
KeyTestResult{alias=key5, success=true, status=, publicKeyHash=46b264e4892ef2e4fd9616e4927534ca3597fd9c}
KeyTestResult{alias=key3, success=true, status=, publicKeyHash=ae64792f1f50e23eb54bf79d46d819bc07db2d79}
KeyTestResult{alias=key2, success=true, status=, publicKeyHash=b1317f363e6124a8e15bba8c1adb9f20b2f4ef59}
KeyTestResult{alias=TS Signer 1, success=true, status=, publicKeyHash=8f6dfccdcea931d4deee9466f43c0eb0e7f4d8b1}
; REPLY_TIME:1350564289165</pre>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td><b>GENCSR</b></td>
                                <td>
                                    <p>
Logged when a certificate signing request (CSR) was generated.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker.<br/>
<b>CSR:</b> Base64 encoded CSR (typically in PKCS#10 format).
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: GENCSR; MODULE: KEY_MANAGEMENT; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: 5676; CSR: MIIBYDCBygIBADAjMRQwEgYDVQQDDAtUUyBTaWduZXIgMTELMAkGA1UEBhMCU0Uw
gZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAJt8F51wD+QcX+WLyIxjWu3at3q+
IiJrL5jIenmggUhjOLHGHOStoNOiYEQAaiiTZ623m9y7O3zhqFdAdWZg+JrfsHQJ
pjKV9RgvJznl6yk/K54BWOBgqjvbloAUGtn8y8Hf+5DYJUJNFqrzvRLcmCQ9JU0H
mgSmEIqgOIwBL3oBAgMBAAEwDQYJKoZIhvcNAQEFBQADgYEAer5hr/cUYx4jy0XO
N4U8sP/2gSFppytx9dn5BamVBLjDkcML8B3c9u9omDPebd+LEsCU+HCmYN9xHkSS
Ei8lcAqyVv+SDLEmvE8gnrPFR/J7uADCRayLVQumW6/YpVO/sFEGuM6rgnn8ZJmW
X2lhvJ4V1UhlkEAeyIQ861U3IgE=; REPLY_TIME:1350891907981</pre>
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <th colspan="2"><i>Status Repository</i></th>
                            </tr>
                            <tr>
                                <td><b>SET_STATUS_PROPERTY</b></td>
                                <td>
                                    <p>
Logged when a status property was updated.
                                    </p>
                                    <p>
<b>STATUSREPO_PROPERTY:</b> The updated property.<br/>
<b>STATUSREPO_VALUE:</b> The new property value.<br/>
<b>STATUSREPO_EXPIRATION:</b> Expiration time for the status property (timestamp), if any.
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: SET_STATUS_PROPERTY; MODULE: STATUS_REPOSITORY; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; STATUSREPO_EXPIRATION: 1350891909366; STATUSREPO_PROPERTY: TEST_PROPERTY1; STATUSREPO_VALUE: TESTVALUE47; REPLY_TIME:1350891908372</pre>
                                    </p>
                                </td>
                            </tr>
                            
                            <tr>
                                <th colspan="2"><i>Worker processing</i></th>
                            </tr>
                            <tr>
                                <td><b>PROCESS</b></td>
                                <td>
                                    <p>
Logged for events regarding worker processing but when a worker logger can not be used because the requested worker does not exist etc.
                                    </p>
                                    <p>
<b>WORKER_ID:</b> The ID of the worker or empty in case of non existing worker.<br/>
<b>Worker logger fields:</b> All fields available to the worker logger.<br/>
                                    </p>
                                    <p>
Example:<br/>
<pre class="code">EVENT: PROCESS; MODULE: WORKER; ADMINISTRATOR: null; ISSUER: null; SERIAL_NUMBER: null; WORKER_ID: null; LOG_ID: db517726-ff0d-40dd-8f2b-2297925cb4d3; CLIENT_IP: 127.0.0.1; PROCESS_SUCCESS: false; REQUEST_LENGTH: 0; XFORWARDEDFOR: null; FILENAME: noname.dat; 
REQUEST_FULLURL: http://localhost:8080/signserver/process?null; LOG_TIME: 1350628977410; WORKER_ID: 0; EXCEPTION: No such worker: 0; REPLY_TIME:1350628977411
</pre>
                                    </p>
                                </td>
                            </tr>
                        </table>
                    </subsubsection>
                </subsection>
 
                <subsection name="Debug Log">
                    <p>
The debug log is just the normal log that can be useful for finding out
configuration problems etc.
                    </p>
                </subsection>

                <subsection name="Configure Log4j for Audit logs">
                    <p>
For JBoss you can configure JBOSS_HOME/server/default/conf/jboss-log4j.xml to
put the audit logs in a separate file.
                    </p>
                    <source>
&lt;appender name="SIGNSERVER_AUDIT" class="org.jboss.logging.appender.DailyRollingFileAppender"&gt;
    &lt;errorHandler class="org.jboss.logging.util.OnlyOnceErrorHandler"/&gt;
    &lt;param name="File" value="${jboss.server.log.dir}/signserver_audit.log" /&gt;
    &lt;param name="Append" value="true" /&gt;

    &lt;!-- Rollover at midnight each day --&gt;
    &lt;param name="DatePattern" value="'.'yyyy-MM-dd" /&gt;
    &lt;layout class="org.apache.log4j.PatternLayout"&gt;
        &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] %m%n" /&gt;
    &lt;/layout&gt;
&lt;/appender&gt;

&lt;category name="org.signserver.server.log.SignServerLog4jDevice"&gt;
    &lt;appender-ref ref="SIGNSERVER_AUDIT"/&gt;
&lt;/category&gt;
&lt;category name="org.signserver.server.log.IWorkerLogger"&gt;
    &lt;appender-ref ref="SIGNSERVER_AUDIT"/&gt;
&lt;/category&gt;
                    </source>
                    <p>
For GlassFish a similar setup is already configured in SIGNSERVER_HOME/modules/SignServer-Module-Log4j/src/log4j.properties. 
                    </p>
                </subsection>
                
                <subsection name="Status Repository Logging">
                    <p>
By default the Status Repository produces a log entry for every update. This can 
be disabled or changed in the configuration so that only changes are 
logged. See the property <i>statusrepository.log</i> in 
signserver_build.properties.sample.
                    </p>
                </subsection>

            </section>
            
            <section name="Database Command Line Interface">
                <p>
The SignServer DB CLI can be run against a database. Currently it only supports 
verifying the audit log.
                </p>
                <subsection name="Building">
                    <p>
The DB CLI is built if the property databasecli.enabled=true is specified in 
signserver_build.properties. It can also be built using:
                    </p>
                    <source>
$ bin/ant -f modules/SignServer-DatabaseCLI/build.xml dist-module
                    </source>
                </subsection>
                
                <subsection name="Configuring">
                    <p>
Configure the dbcli.* properties in conf/signserver_cli.properties.
                    </p>
                </subsection>
                
                <subsection name="Running">
                    <p>
There is start-up script available under bin. You might have specify a classpath
containing the JDBC connectors for the specific database type. Example:
                    </p>
                    <source>
$ OPTIONAL_CLASSPATH=/usr/share/java/mysql-connector-java.jar bin/signserver-db audit verifylog
                    </source>
                </subsection>
            </section>

            <section name="SignServer without Database">
                <p>
Since SignServer 3.2.3 it is sometimes possible to operate SignServer without a database management system and instead rely on SignServer to manage persistence using local files.
                </p>
                <p>
Notice that all features of SignServer is not supported without having a database and that the performance and scalability characteristics might be different. Currently archiving to database and the group key service are not supported.
                </p>
                <p>
To increase throughput it is recommended to disable the key usage counter as every request would otherwise have to lock and update that file. See the property DISABLEKEYUSAGECOUNTER in the section <a href="complete.en.html#Limiting%20the%20number%20of%20signatures">Limiting the number of signatures</a>.
                </p>
                
                <subsection name="Configuration">
                    <p>
In signserver_build.properties, set database.type to "nodb".
                    </p>
					<source>
database.type=nodb
					</source>
					<p>
Set the location for the local file-based database.
					</p>
					<source>
database.nodb.location=/path/to/filedb
					</source>
					<p>
Where the path is some location where SignServer can write files. The default value is empty. If an relative path is used it is most likely relative to the application server's working directory.
					</p>
					<p>
This directory should either point to an existing SignServer file database or be completely empty. If the directory is empty, SignServer will create the initial database structure at startup.
					</p>
                </subsection>
                
                <subsection name="Structure of data">
                    <p>
The file based database uses a number of files in the specified directory. Read/write synchronization is handled internally in the application and it is thus  not support to do manual changes to the files while the application server is running. It is normally also not supported to have multiple application servers running with SignServer using the same database directory.
                    </p>
                </subsection>
                
                <subsection name="Migrating to/from database">
                    <p>
The recommended way of migrating either to or from an other database management system without setting up all worker configuration from scratch is do use admin command "dumpproperties" to dump the current configuration to a file and then on the new system use the "setproperties" followed by the reload command for every worker id.
                    </p>
                    <p>
Notice: The dumpproperties command will not include the list of authorized clients so those will have to be setup again in the new system. Check with the admin command "listauthorizedclients" if you have any of those.
                    </p>
                </subsection>
                
            </section>

            <section name="Installation Packages">
                <p>
See res/install/debian/README.building for instructions for creating Debian packages for SignServer.
                </p>
            </section>

            <section name="Contributed Howtos">
                <p>
Contributed howtos and installation guides can be found under doc/howtos.
                </p>
                <ul>
                    <li>
Installation guide for SignServer 3.1 and RHEL5.3 / CentOS 5.3 by Christophe Sahut called signserver31-rhel5.txt.                        
                    </li>
                    <li>
Installation package for SignServer 3.2.4 and Debian 6.0 contributed by Antoine Louiset called signserver32-debian6-by-antoine-louiset.zip.
                    </li>
                </ul>
            </section>

            <section name="References">
                <ul>
                    <li>Java  (<a href="http://java.sun.com">http://java.sun.com</a>)</li>
                    <li>JBoss  (<a href="http://www.jboss.org">http://www.jboss.org</a>)</li>
                    <li>Apache Ant (<a href="http://ant.apache.org">http://ant.apache.org</a>)</li>
                    <li>Bouncycastle (<a href="http://www.bouncycastle.org">http://www.bouncycastle.org</a>)</li>
                    <li>RFC3161, Time-Stamp Protocol (TSP) (<a href="http://www.ietf.org">http://www.ietf.org</a>)</li>
                </ul>
            </section>
            
        </chapter>
    </body>
</document>

