# File containing internal localization messages used by 
# log comments, approval notifications and some exceptions.
#
# The keys should be sections into which module the message
# originates from, example raadmin.msg1 or keyrecovery.testmessage
#
# PORTUGUESE VERSION

# This are resources only used with the test script
raadmin.testmsg       = Teste PT_BR                        
raadmin.testparams    = Teste {0} {1} {2} {3} {4} mensagem {0} 


services.serviceadded             = Serviço {0} adicionado.
services.erroraddingservice       = Erro adicionando serviço {0}
services.notauthorizedtoadd       = Erro, não autorizado adicionando serviço : {0}
services.serviceedited            = Serviço {0} editado.
services.erroreditingservice      = Erro no serviço {0}.
services.notauthorizedto          = Erro, não autorizado para o serviço : {0}
services.servicecloned            = Novo serviço {0}, usado serviço {1} como modelo.
services.errorcloningservice      = Erro adicionando serviço {0} usando serviço {1} como modelo.
services.serviceremoved           = Serviço {0} removido.
services.errorremovingservice     = Erro removendo fonte de dados de utilizadores {0}.
services.servicerenamed           = Serviço {0} renomeado para {1}.
services.errorrenamingservice     = Erro renomeando Serviço {0} para {1}.
services.serviceexecuted          = Serviço {0} executado com sucesso.
services.servicenotfound          = Serviço com ID {0} não foi encontrado.
services.serviceexecutionfailed   = Execução do Serviço {0} falhou.
services.servicerunonothernode    = Serviço {0} foi executado noutro nodo do cluster. Aguardando.
services.erroractionclasspath = Serviço de Monitorização de Erros {0} actionClassPath não está configurado corretamente.
services.errorintervalclasspath = Serviço de Monitorização de Erros {0} intervalClassPath não está configurado corretamente; o serviço não será executado.
services.errorworkerconfig = Worker {0} não está configurado corretamente para o serviço {1}; verifique a classpath.
services.errorworker.errornoemail = Envio de notificação por email para o utilizador {0} falhou; não foi configurado nenhum endereço de email.
services.errorworker.errornoca = AC com id {0} e nome '{1}' não existe quando checando para renovação. Ela foi removida?
services.errorexpireworker.errorconfig = Erro: Worker de Notificações de Expiração {0} não está configurado corretamente; verifique o valor de {1}.
services.interval.errorconfig = Erro: Serviço periódico {0} não está configurado corretamente; verifique o valor de {1}. 
services.mailaction.errorreceiveraddress = Erro: Não foi encontrado o endereço do destinatário.
services.mailaction.errorsenderaddress = Erro: Tem de ser configurado um endereço de remetente.
services.mailaction.sent = Notificação por email foi enviada para {0} com sucesso.
services.mailaction.errorsend = Erro no envio de notificação por email para {0}.
services.mailaction.erroractioninfo = Erro: Apenas é suportado MailActionInfo.

services.upgrade = Atualizando configuração de serviço com a versão {0}.


# Notification resources

notification.newrequest.subject      = Novo Pedido de Aprovação EJBCA (${approvalRequest.ID}) para ${approvalRequest.TYPE} efectuado por ${requestAdmin.CN} ${requestAdmin.O}

notification.newrequest.msg          = ${NL}${NL}Foi criado um pedido de aprovação para ${approvalRequest.TYPE} por ${requestAdmin.CN} ${requestAdmin.O} a ${approvalRequest.DATE}${NL}${NL}Para rever e aprovar o pedido siga a ligação ${approvalRequest.APROVEURL} para mais detalhes. ${NL}${NL}São necessárias mais ${approvalRequest.APPROVALSLEFT} aprovações para a ação ser executada.

notification.requestconcured.subject = Pedido de Aprovação EJBCA (${approvalRequest.ID}) para ${approvalRequest.TYPE} foi aceite por ${approvalAdmin.CN} ${approvalAdmin.O}.

notification.requestconcured.msg     = ${NL}${NL}O administrador ${approvalAdmin.CN} ${approvalAdmin.O} concordou com o pedido de aprovação para ${approvalRequest.TYPE} por ${requestAdmin.CN} ${requestAdmin.O} a ${approvalRequest.DATE}. ${NL}${NL}O comentário registado pelo administrador foi o seguinte: ${approvalRequest.APPROVALCOMMENT}${NL}${NL}Falta aindobtendo o acordo de ${approvalRequest.APPROVALSLEFT} administradores autorizados. Para rever e aprovar o pedido, siga a ligação ${approvalRequest.APROVEURL} para mais detalhes. 

notification.requestapproved.subject = O Pedido de Aprovação EJBCA (${approvalRequest.ID}) para ${approvalRequest.TYPE} foi APROVADO por ${approvalAdmin.CN} ${approvalAdmin.O}

notification.requestapproved.msg     = ${NL}${NL}Dependendo do tipo de pedido, o administrador poderá agora acessar a informação ou a ação foi executada.${NL}${NL}O comentário registado pelo administrador foi o seguinte: ${approvalRequest.APPROVALCOMMENT}${NL}${NL}Siga a ligação ${approvalRequest.APROVEURL} para mais detalhes.

notification.requestrejected.subject = O Pedido de Aprovação EJBCA (${approvalRequest.ID}) para ${approvalRequest.TYPE} foi REJEITADO por ${approvalAdmin.CN} ${approvalAdmin.O}

notification.requestrejected.msg     = ${NL}${NL}O pedido de aprovação (${approvalRequest.ID}) para ${approvalRequest.TYPE} foi REJEITADO por ${approvalAdmin.CN} ${approvalAdmin.O} e a ação não será executada. ${NL}${NL}O comentário registado pelo administrador para a rejeição foi o seguinte: ${approvalRequest.APPROVALCOMMENT}${NL}${NL}Siga a ligação ${approvalRequest.APROVEURL} para mais detalhes.

# Sign session resource
signsession.requestcert = Recebido pedido de certificado para o utilizador {0} para a AC {1} com o perfil de certificado {2}.
signsession.nouserinrequest = Nenhum utilizador definido no pedido; DN do pedido: {0}.
signsession.nopasswordinrequest = Nenhuma senha no pedido.
signsession.nokeyinrequest = Nenhuma chave pública no pedido.
signsession.wrongauthority = AC do pedido ({0}) não condiz com a AC utilizada ({1}).
signsession.nosuchuser = Utilizador {0} inexistente.
signsession.finishnouser = Chamado finishUser para utlizador {0} inexistente.
signsession.unsupportedkeytype = Chave pública ({0}) não suportada; apenas suportadas chaves RSA e ECDSA.
signsession.illegalkeylength = Tamanho de chave não permitido: {0}.
signsession.certificateissued = Certificado emitido para utilizador {0}.
signsession.popverificationfailed = Verificação da Prova de Posse falhou.
signsession.canotactive = AC para assinatura {0} não está ativa.
signsession.caexpired = AC para assinatura {0} expirou.
signsession.canotyetvalid = AC para assinatura {0} ainda não é válida.
signsession.canotfoundissuerusername = Não é possível encontrar o ID da AC a partir do DN de emissor '{0}' ou utilizador '{1}'.
signsession.canotfoundcaid =  ID de AC inválido: {0}.
signsession.createdcrl = Criada CRL com o número {0} para a AC {1} com o DN: {2}. 
signsession.errorcreatecrl = Erro criando CRL.
signsession.nocrlcreate = Nenhum CRL foi criada para a AC {0}. 
signsession.usertypeinvalid = Tipo de utilizador é USER_INVALID; não é possível criar certificado para o utilizador.
signsession.errorcertprofiletype = Tipo de Certificado ({0}) errado para titular. Apenas podem ser emitidos certificados para perfis de certificado para titulares pelo bean signsession.
signsession.errorcertprofilenotauthorized = Registo do titular contém a AC {0}, cujo perfil de certificado {1} não está autorizado a usar.
signsession.errorupgradingxkmsservice = Erro iniciando serviço XKMS na atualização da AC {0}.
signsession.errorupgradingcmsservice = Erro iniciando serviço CMS na atualização da AC {0}.
signsession.limitingvalidity = Limitando validade do certificado, porque a validade pretendida ({0}) excede a valida da AC ({1}).
signsession.errorpathverifykeyid = AuthorityKeyId do certificado emitido ({0}) não corresponde ao SubjectKeyId do certificado da AC ({1}).
signsession.errorpathverifydn = DN do emissor do certificado emitido ({0}) não corresponde ao DN de sujeito do certificado da AC ({1}).
signsession.errorbeyondmaxvalidity = Data de fim de validade do pedido ({0}) para o utilizador '{1}' é maior que o máximo permitido pelo perfil de certificado ({2}); será utilizada a validade definida pelo perfil de certificado.
signsession.errorbeforecurrentdate = Data de início de validade do pedido ({0}) para o utilizador '{1}' é anterior é data atual; será usada a data atual.
signsession.errorinvalidstarttime = Ignorando formato inválido de instante de início ({0}).
signsession.errorinvalidcausality = Data de início ({0}) é posterior é data de fim ({1}). Tentativa de recuperação por troca das datas.
 
cvc.info.renewallowed = Verificação de assinatura externa na requisição CVC foi bem sucedida com certificado válido de fp {0}. Requisição permitida para usuário {1}.
cvc.error.outersignature = Verificação de assinatura externa na requisição CVC falhou para holderRef (portador) '{0}'. Mensagem: {1}.
cvc.error.renewsamekeys = Tentando renovar um certificado usando a mesma chave para holderRef (portador) '{0}'.
cvc.error.notcvcrequest = Requisição não é uma requisição do tipo CVCertificate.
cvc.info.nocvcpkcs7 = PKCS7 não existe para certificados CV. 
cvc.info.createlinkcert = Criando um link de certificado CVCA para '{0}' emitido por '{1}'.

caadmin.notauthorizedtocreateca = Administrador não autorizado para criar AC {0}.
caadmin.notauthorizedtoeditca = Administrador não autorizado para editar AC {0}.
caadmin.notauthorizedtoremoveca = Administrador não autorizado para remover AC com ID {0}.
caadmin.notauthorizedtorenameca = Administrador não autorizado para renomear AC com ID {0}.
caadmin.notauthorizedtocertreq = Administrador não autorizado para obter pedido de certificado para AC {0}.
caadmin.notauthorizedtocertresp = Administrador não autorizado para receber resposta de certificado para AC {0}.
caadmin.notauthorizedtocertresp = Administrador não autorizado para processar AC {0}.
caadmin.notauthorizedtorenew = Administrador não autorizado para renovar AC {0}.
caadmin.notauthorizedtorevoke = Administrador não autorizado para revogar AC {0}.
caadmin.notauthorizedtoativatetoken = Administrador não autorizado para ativar token da AC {0}.
caadmin.notauthorizedtodeativatetoken = Administrador não autorizado para desativar token da AC {0}.
caadmin.wrongcaid = ID de AC {0} não permitido; AC não pode ser criada.
caadmin.caexistsid = Já existe AC com ID {0}.
caadmin.caexistsname = Já existe AC com nome {0}.
caadmin.errorcreatetoken = Erro criando token de AC.
caadmin.errorcreatetokenpin = Erro criando token de AC por hardware. Côdigo de autorização errado.
caadmin.errorcreateca = Não foi possível criar AC {0}.
caadmin.errorcreatecaservice = Não foi possível criar serviço de externo de AC {0}.
caadmin.erroreditca = Não foi possível editar AC {0}.
caadmin.errorremoveca = Não foi possível remover AC {0}. Message: {1}.
caadmin.errorrenameca = Não foi possível renomear AC {0}.
caadmin.errorgetcainfo = Erro obtendo informação de AC para {0}.
caadmin.errorcertreq = Erro criando pedido de certificado para AC {0}.
caadmin.errorcertresp = Erro recebendo resposta de certificado para AC {0}.
caadmin.errorcertreqsign = Erro assinando requisição de certificado para AC {0}.
caadmin.errorprocess = Erro processando AC {0}.
caadmin.errorrenewca = Erro renovando AC {0}.
caadmin.errorrevoke = Erro revogando AC {0}.
caadmin.errorcertreqinternalca = Não é possível criar pedido de certificado para AC interna {0}.
caadmin.errorcertrespinternalca = Não é possível receber resposta de certificado para AC interna {0}.
caadmin.errorcertrespillegalmsg = Mensagem de resposta inválida.
caadmin.errorcertrespwrongdn = DN de sujeito do certificado recebido ({0} não corresponde ao pedido ({1}).
caadmin.errorcaexists = Erro processando AC {0}. AC já existe.
caadmin.errorativatetoken = Erro na tentativa de ativar token da AC {0}.
caadmin.errordeativatetoken = Erro na tentativa de desativar token da AC {0}.
caadmin.errornotoffline = AC {0} tem de estar no estado 'desativada' para poder ser ativada.
caadmin.errornotonline = AC {0} tem de estar no estado 'ativada' para poder ser desativada.
caadmin.errorcanotfound = Erro na tentativa de acessar é AC com o ID {0}. AC inexistente.
caadmin.errorreadingtoken = Erro obtendo CATokenInfo para a AC {0}.
caadmin.createdca = AC {0} criada com sucesso. Estado: {1}. 
caadmin.editedca = AC {0} editada. 
caadmin.removedca = AC {0} removida.
caadmin.renamedca = AC {0} renomeada para {1}.
caadmin.processedca = AC {0} processada com sucesso.
caadmin.renewdca = AC {0} renovada com sucesso.
caadmin.revokedca = AC {0} revogada com sucesso; razão: {1}.
caadmin.catokenativated = Token da AC {0} ativado com sucesso. 
caadmin.catokendeativated = Token da AC {0} desativado com sucesso. 
caadmin.certreqcreated = Pedido de certificado gerado com sucesso para AC {0}.
caadmin.certrespreceived = Resposta de certificado recebida com sucesso para AC {0}.
caadmin.exportedca = AC '{0}' exportdada com sucesso para arquivo {1}.
caadmin.errorexportca = Erro na exportação da AC '{0}' para arquivo {1} : {2}.
caadmin.importedca = AC '{0}' importada com sucesso do antigo arquivo {1}. Estado: {2}. 
caadmin.errorimportca = Erro a importar AC '{0} do arquivo {1} : {2}.

authorization.admingroupadded = Grupo de administração {0} adicionado.
authorization.erroraddadmingroup = Erro adicionando grupo de administração {0}.
authorization.admingroupremoved = Grupo de administração {0} removido.
authorization.errorremoveadmingroup = Erro removendo grupo de administração {0}.
authorization.admingrouprenamed = Grupo de administração renomeado de {0} para {1}.
authorization.errorrenameadmingroup = Erro renomeando grupo de administração de {0} para {1}.
authorization.accessrulesadded = Adicionadas regras de acesso para grupo de administração {0}.
authorization.erroraddaccessrules = Erro adicionando regras de acesso para grupo de administração {0}.
authorization.accessrulesremoved = Regras de acesso removidas do grupo de administração {0}.
authorization.errorremoveaccessrules = Erro removendo regras de acesso do grupo de administração {0}.
authorization.accessrulesreplaced = Regras de acesso do grupo de administração {0} substituídas.
authorization.errorreplaceaccessrules = Erro substituindo regras de acesso do grupo de administração {0}.
authorization.adminadded = Adicionador administradores ao grupo de administração {0}.
authorization.erroraddadmin = Erro adicionando administradores ao grupo de administração {0}.
authorization.adminremoved = Administradores removidos ao grupo de administração {0}.
authorization.errorremoveadmin = Erro removendo administradores do grupo de administração {0}.
authorization.errorcreateauthtree = Erro criando AuthorizationTreeUpdateDataBean.
 
authentication.invalidpwd = Recebido pedido para utilizador com senha inválida: {0}.
authentication.authok = Utilizador autenticado {0}.
authentication.wrongstatus = Recebido pedido com estado {0} ({1}); necessário estar no estado NOVO, FALHOU ou EM PROCESSAMENTO: {2}.
authentication.usernotfound = Recebido pedido para utilizador inexistente: {0}.
authentication.statuschanged = Alterado estado para GERADO.

createcrl.createdcrl = Emitida CRL para AC {0}, com DN: {1}. 
createcrl.errorcreate = Erro emitindo CRL para AC {0}. 
createcrl.caoffline = AC {0}, {1} está desativada. CRL não pode ser emitida.
createcrl.errornotactive = AC {0}, {1} está desativada. CRL não pode ser criada. Status é {2}.
createcrl.catokenoffline = Token da AC {0}, {1} está desativado. CRL não pode ser emitida.
createcrl.crlinfonull = Crlinfo está "null"; campo nextUpdate fica com 0.
createcrl.generalerror = Erro emitindo CRL para AC {0}.
createcrl.erroravailcas = Erro obtendo ACs disponíveis.

publisher.store = Publicado objeto {0} com sucesso no publicador {1}.
publisher.errorstore = Erro a publicar em {0}.
publisher.nopublisher = Publicador com ID {0} inexistente.
publisher.testedpublisher = Ligação com publicador {0} testada com sucesso.
publisher.errortestpublisher = Erro a testar ligação com publicador {0}.
publisher.addedpublisher = Publicador {0} adicionado.
publisher.erroraddpublisher = Erro adicionando publicador {0}.
publisher.changedpublisher = Publicador {0} editado.
publisher.errorchangepublisher = Erro editando publicador {0}.
publisher.clonedpublisher = Novo publicador {0} usou publicador {1} como modelo.
publisher.errorclonepublisher = Erro adicionando publicador {0} usando publicador {1} como modelo.
publisher.removedpublisher = Publicador {0} removido.
publisher.errorremovepublisher = Erro removendo publicador {0}.
publisher.renamedpublisher = Publicador {0} renomeado para {1}.
publisher.errorrenamepublisher = Erro renomeando publicador {0} para {1}.

store.storecert = Certificado guardado.
store.errorstorecert = Erro guardando certificado.
store.storecrl = Número de CRL: {0}, marca: {1}.  
store.storecrlwrongnumber = Tentando guardar uma CRL com o número {0}, mas já existe uma CRL com o número {1}.
store.errorcertinfo = Erro procurando certificado com marca {0}.
store.errorfindcertuser = Não foi possível procurar certificado do utilizador {0}.
store.errorfindcertserno = Não foi possível procurar certificado com S/N {0}.
store.revokedcert = Certificado revogado. Razão: {0}.
store.republishunrevokedcert = Republicado certificado reativado. Razão: {0}. 
store.ignorerevoke = Pedido setRevokeStatus() ignorado para S/N: {0}. Estado atual do certificado: {1}. Razão de revogação: {2}.
store.revokedallbyca = Revogados todos os certificados emitidos por {0} com sucesso. Revogados permanentemente {1} certificados com razão {2}.
store.errorrevokeallbyca = Erro na tentativa de revogar todo os certificados emitidos por {0}.
store.getcrl = Obtida CRL do emissor {0}, com número {1}.
store.errorgetcrl = Erro obtendo CRL para o emissor {0} com número {1}.
store.errorgetcrlinfo = Erro obtendo informação de CRL para emissor {0}.
store.storehistory = Guardando histôrico de pedidos de certificado para utilizador {0} com sucesso.
store.errorstorehistory = Erro guardando histôrico de pedidos de certificado para utilizador {0}.
store.removehistory = Remoção de histôrio de pedidos de certificado para a marca {0} com sucesso.
store.errorremovehistory = Erro removendo histôrico de pedidos de certificado para marca {0}.
store.errorcertprofilefixed = Erro processando perfil de certificado {0}; perfil fixo ou com nome.
store.errorcertprofileexists = Perfil de Certificado {0} já existente.
store.addedcertprofile = Novo perfil de certificado {0} adicionado com sucesso.
store.errorcreatecertprofile = Erro criando novo perfil de certificado {0}.
store.erroraddprofilewithtempl = Erro adicionando perfil de certificado {0} usando perfil {1} como modelo.
store.addedprofilewithtempl = Novo perfil de certificado {0} adicionado usando perfil {1} como modelo.
store.removedprofile = Perfil de certificado {0} removido.
store.errorremoveprofile = Erro removendo perfil de certificado {0}.
store.renamedprofile = Perfil de certificado {0} renomeado para {1}.
store.errorrenameprofile = Erro renomeando perfil de certificado de {0} para {1}.
store.editedprofile = Perfil de certificado {0} editado.
store.erroreditprofile = Erro editando perfil de certificado {0}.
store.errorseveralissuerserno = Erro na base de dados; mais do que um certificado tem o mesmo par (emissor: {0}, número de série {1}).

hardtoken.userdatasent = Dados do utilizador enviados para geração do token pelo emissor {0}.
hardtoken.errorsenduserdata = Erro obtendo o prôximo token para o emissor {0}.
hardtoken.addedprofile = Perfil de hard token {0} adicionado.
hardtoken.erroraddprofile = Erro adicionando perfil de hard token {0}.
hardtoken.editedprofile = Perfil de hard token {0} editado.
hardtoken.erroreditprofile = Erro editando perfil de hard token {0}.
hardtoken.clonedprofile = Novo perfil de hard token {0} usando perfil {1} como modelo."
hardtoken.errorcloneprofile = Erro adicionando perfil de hard token {0}, usando perfil {1} como modelo."
hardtoken.removedprofile = Perfil de hard token {0} removido.
hardtoken.errorremoveprofile = Erro removendo perfil de hard token {0}.
hardtoken.renamedprofile = Perfil de hard token {0} renomeado para {1}. 
hardtoken.errorrenameprofile = Erro renomeando perfil de hard token {0} para {1}. 
hardtoken.addedissuer = Emissor de hard token {0} adicionado.
hardtoken.erroraddissuer = Erro adicionando emissor de hard token {0}.
hardtoken.editedissuer = Emissor de hard token {0} editado.
hardtoken.erroreditissuer = Erro editando emissor de hard token {0}.
hardtoken.clonedissuer = Novo emissor de hard token {0}, usando {1} como modelo."  
hardtoken.errorcloneissuer = Erro adicionando emissor de hard token {0}, usando {1} como modelo."  
hardtoken.removedissuer = Emissor de hard token {0} removido.
hardtoken.errorremoveissuer = Erro removendo emissor de hard token {0}.
hardtoken.renameissuer = Emissor de hard token {0} renomeado para {1}.
hardtoken.errorrenameissuer = Erro renomeando emissor de hard token {0} para {1}.
hardtoken.unavailabletoken = Emissor de hard token não pode emitir tipo de token especificado para o utilizador {0}. Altere o tipo de token ou emissor de hard token para o utilizador.
hardtoken.addedtoken = Hard token com número de série {0} adicionado.
hardtoken.tokenexists = Hard token com número de série {0} já existe.
hardtoken.changedtoken = Hard token com número de série {0} alterado.
hardtoken.errorchangetoken = Erro a alterar hard token com número de série {0}.
hardtoken.removedtoken = Hard token com número de série {0} removido.
hardtoken.errorremovetoken = Erro removendo hard token com número de série {0}.
hardtoken.viewedtoken = Hard token com número de série {0} visualizado.
hardtoken.viewedpuk = PUK do hard token com número de série {0} visualizado.
hardtoken.addedtokencertmapping = Mapeamento de certificado adicionado; S/N do certificado: {0}, S/N do token: {1}.
hardtoken.erroraddtokencertmapping = Erro adicionando mapeamento de certificado; S/N do certificado: {0}, S/N do token: {1}.
hardtoken.removedtokencertmappingcert = Mapeamento de certificado removido; S/N do certificado: {0}.
hardtoken.errorremovetokencertmappingcert = Erro removendo mapeamento do certificado; S/N do certificado: {0}.
hardtoken.removedtokencertmappingtoken = Mapeamento do certificado removido; S/N do certificado: {0}.
hardtoken.errorremovetokencertmappingtoken = Erro removendo mapeamento do certificado; S/N do certificado: {0}.
hardtoken.generatedtoken = Token com número de série {0} gerado com sucesso.
hardtoken.errorgeneratetoken = Erro gerando token com número de série {0}.

keyrecovery.addedforapproval = Ação de recuperação de chave foi adicionada para aprovação por administradores autorizados.
keyrecovery.addeddata = Adicionados dados de recuperação de chave para certificado com número de série {0} e emissor {1}.
keyrecovery.erroradddata = Erro adicionando dados de recuperação de chave para certificado com número de série {0} e emissor {1}.
keyrecovery.changeddata = Alterados dados de recuperação de chave para certificado com número de série {0} e emissor {1}.
keyrecovery.errorchangedata = Erro a atualizar dados de recuperação de chave para certificado com número de série {0} e emissor {1}. 
keyrecovery.removeddata = Removidos dados de recuperação de chave para certificado com número de série {0} e emissor {1}.
keyrecovery.errorremovedata = Erro removendo dados de recuperação de chave para certificado com número de série {0} e emissor {1}. 
keyrecovery.removeduser = Removidos todos os dados de recuperação de chave para utilizador {0}.
keyrecovery.errorremoveuser = Erro removendo todos os dados de recuperação de chave para utilizador {0}.
keyrecovery.sentdata = Foram enviados dados essenciais do utilizador {0} para recuperação de chave.
keyrecovery.errorsenddata = Erro a recuperar dados essenciais da chave para o utilizador {0}.
keyrecovery.markeduser = Certificado mais recente do utiliador {0} foi marcado para recuperação de chave.
keyrecovery.errormarkuser = Erro a marcar o certificado mais recente do utilizador {0} para recuperação de chave.
keyrecovery.markedcert = Certificado com número de série {0} e emissor {1} marcado para recuperação de chave.
keyrecovery.errormarkcert = Erro a marcar certificado com número de série {0} e emissor {1} para recuperação de chave.

log.errormissingentry = Dispositivo de log gerou uma excessão.
log.errorcreateconf = Erro criando nova configuração de log para AC com ID {0}.
log.createconf = Não foi possível encontrar configuração de log durante a gravação para AC com ID {0}. A criar nova configuração.
log.notauthtocustomlog = Não autorizado criando log personalizado.
log.warningduplicatekey = Chave primária de logs duplicada durante um registo de log (DuplicateKeyException). O contador de logs vai ser incrementado e o registo do log será tentado de novo.

protect.errorcreatesession = ERRO PROTEÇÃO: Não foi possível criar TableProtectSession:
protect.rowexistsupdate = INFO PROTEÇÃO: registo protegido para entrada do tipo {0}, com a chave {1} já existe. Atualizado.
protect.errorcreate = ERRO PROTEÇÃO: não é possível criar registo protegido para entrada do tipo {0}, com a chave {1}.
protect.errorverify = ERRO PROTEÇÃO: verificação falha para a entrada do tipo {0}, com a chave {1}.
protect.errorverifynokey = ERRO PROTEÇÃO: verificação falha para a entrada do tipo {0}, com a chave {1}. Chave não existe.
protect.errorverifyalg = ERRO PROTEÇÃO: verificação falha para a entrada do tipo {0}, com a chave {1}. Algoritmo incompatível.
protect.errorverifywronghash = ERRO PROTEÇÃO: hash errado para entrada do tipo {0}, com a chave {1}.
protect.errorverifynorow = ERRO PROTEÇÃO: não é possível encontrar registo protegido para entrada do tipo {0}, com a chave {1}.
protect.errorverifycant = ERRO PROTEÇÃO: não é possível verificar registo protegido para entrada do tipo {0}, com a chave {1}.

protectedlog.abstainexport = Logs não exportados. Outro nodo já está a fazer o mesmo.
protectedlog.acceptedchain = Cadeia de nodos {0} aceite.
protectedlog.canceledexp = Exportação cancelada.
protectedlog.canceledver = Verificação cancelada.
protectedlog.mafailed = MailAction falhou.
protectedlog.macause = A causa do problema foi {0}.
protectedlog.nonewevents = Não há eventos novos para exportar.
protectedlog.progress = Exportação de logs está processando {0} eventos de log. ({1} eventos de log no total até ao momento)
protectedlog.saerrorcode = Executável de destino terminou com um código de erro.
protectedlog.safailed = ScriptAction falhou.
protectedlog.sanotarget = Não foi especificado nenhum destino.
protectedlog.startingexport = A iniciar procedimento de exportação.
protectedlog.waitingforservice = A aguardar até {0} segundos pela paragem dos serviços.
protectedlog.sda.killingjvm = A terminar a JVM agora!
protectedlog.cause.unknown = Erro desconhecido.
protectedlog.cause.internalerror = Ocorreu um erro interno. Pode ser causado por uma configuração errada ou por um defeito.
protectedlog.cause.testing = Este evento foi gerado para apenas para teste e não é um erro.
protectedlog.cause.missingtoken = Falta um token usado para proteger a linha de log.
protectedlog.cause.modifiedtoken = Um token usado para proteger a linha de log foi adulterado.
protectedlog.cause.missinglogrow = Falta uma linha de log.
protectedlog.cause.modifiedlogrow = Uma linha de log foi adulterada.
protectedlog.cause.emptylog = O log está vazio. Isto é normal apenas acabou de instalar o serviço.
protectedlog.cause.rolledback = O log voltou a um estado anterior.
protectedlog.cause.frozen = Desde há muito tempo que nada é adicionado aos logs.
protectedlog.cause.invalidtoken = O token não era válido na data de uso.
protectedlog.cause.modifiedexport = O registo de exportação foi modificado.
protectedlog.cause.invalidexport = Registo de exportação inválido.
protectedlog.cause.unverifyablechain = Foi encontrada uma cadeia que não está ligada a nenhuma outra cadeia.
protectedlog.error.canotworking = A AC {0} não pôde ser usada para efetuar assinaturas.
protectedlog.error.catokenoffline = Não é possível exportar porque o token da AC está desativado.
protectedlog.error.couldnotfetch = Não foi possível obter o evento de log ({0}, {1}).
protectedlog.error.emptyorunprotected = O log está vazio ou desprotegido.
protectedlog.error.exportverify = Falha na exportação. Não foi possível verificar a cadeia de nodos em {0}, {1}.
protectedlog.error.frozen = Nodo congelado. Desde há muito tempo que nada é adicionado ao nodo {0}.
protectedlog.error.handlerupdate = Erro na exportação durante a atualização.
protectedlog.error.handlerdone = Erro na exportação durante da finalização.
protectedlog.error.internallogerror = Erro interno de logs.
protectedlog.error.invalidlastexport = A última exportação é inválida.
protectedlog.error.invalidtokencert = Certificado de token inválido.
protectedlog.error.logdropped = Forçado a descartar evento de log (encerramento em curso): "{0}". Isto foi causado por {1}.
protectedlog.error.logrowchanged = Evento de log ({0}, {1}) foi modificado na base de dados.
protectedlog.error.logrowmissing = Evento de log ({0}, {1}) está em falta na base de dados.
protectedlog.error.logunprotected = Forçado registro de  evento de log desprotegido (encerramento em curso): "{0}". Usar accept-CLI para assinar este evento.
protectedlog.error.noexportcacert = Não existe nenhum certificado de AC válido para utilizar na exportação de logs.
protectedlog.error.notoken = Nenhum token disponível para o evento de log ({0}, {1}).
protectedlog.error.reverttonone = Não foi encontrada a AC pretendida. Revertendo para "nenhuma".
protectedlog.error.rolledback = Foi feito um roll back do log.
protectedlog.error.tokenmissing = Não foi possível encontrar o token de proteção de log pretendido ({0}).
protectedlog.error.tokennotfound = Não foi possível encontrar o token de proteção de log pretendido ({0}). Isto é normal quando é usado um novo token.
protectedlog.error.tokennotworking = O token {0} não pôde ser usado para proteção.
protectedlog.error.unprotectednode = Não foram encontrados eventos de log protegidos no nodo {0}.
protectedlog.verifier.failed = Verificação de logs falhou em {0} {1}.
protectedlog.warn.usingunsafeconfig = Usar {0}=true e {1}>0 não é seguro em ambientes onde há mais de um nodo a correr em simultâneo.

ra.adminprefadded = Preferência de administrador com ID {0} adicionada. 
ra.changedadminpref = Preferência de administrador {0} alterada.
ra.adminprefexists = Tentativa de adicionar preferência de administrador já existente.
ra.adminprefnotfound = Preferência de administrador {0} não foi encontrada na base de dados. 
ra.defaultadminprefsaved = Preferência de administrador por omissão alterada.
ra.errorsavedefaultadminpref = Erro a gravar preferência de administrador por omissão.
ra.addedprofile = Perfil de titular {0} adicionado.
ra.erroraddprofile = Erro adicionando perfil de titular {0}.
ra.clonedprofile = Adicionado novo perfil de titular {0} usando perfile {1} como modelo.
ra.errorcloneprofile = Erro adicionando novo perfil de titular {0} usando perfil {1} como modelo.
ra.removedprofile = Perfil de titular {0} removido.
ra.errorremoveprofile = Erro removendo perfil de titular {0}.
ra.renamedprofile = Perfil de titular {0} renomeado para {1}.
ra.errorrenameprofile = Erro renomeando perfil de titular {0} para {1}.
ra.changedprofile = Perfil de titular {0} editado.
ra.errorchangeprofile = Erro editando perfil de titular {0}.
ra.savedconf = Configuração global com ID {0} guardada.
ra.createdconf = Criada configuração glogal com ID {0}.
ra.errorcreateconf = Falha na criação de configuração global.
ra.errorgetids = Erro obtendo IDs de perfis de titulares autorizados.
ra.errorreadprofiles = Erro obtendo perfis de titulares.

ra.errorfullfillprofile = Dados de utilizador violam perfil de titular {0}, dn '{1}: {2}.
ra.errorauthprofile = Administrador não autorizado ao perfil de titular {0}.
ra.errorauthca = Administrador não autorizado é AC {0}.
ra.errorcertnoadmin = O seu certificado não pertence a um administrador. Emissor {0}, número de série {1}.
ra.errorcertnouser = O seu certificado não pertence a nenhum utilizador. Emissor {0}, número de série {1}.
ra.errorprint = Erro imprimindo dados do utilizador {0}. Mensagem: {1}.
ra.approvalad = Ação de Adicionar Titular foi registada para aprovação por administradores autorizados.
ra.approvaledit = Ação de Alteração de Titular foi registada para aprovação por administradores autorizados.
ra.approvalrevoke = Ordem de revogação foi enviada para aprovação por administradores autorizados.
ra.approvalcaativation = Pedido de ativação da AC foi enviado para aprovação por administradores autorizados.
ra.errorrevocationexists = Certificado já está revogado.
ra.addedentity = Titular {0} adicionado.
ra.errorentityexist = Titular {0} já existe.
ra.errorentitynotexist = Titular {0} inexistente.
ra.erroraddentity = Erro adicionando titular.
ra.decreasedentityrequestcounter = Contador de pedidos decrementado para o titular {0}, novo valor {1}.
ra.errorrequestcounterinvalid = Contador de pedidos '{0}' inválido para o titular {1}, erro: {2}.
ra.errorallowedrequestsinvalid = Valor inválido '{0}' para pedidos permitidos para o titular {1}, erro: {2}.
ra.editedentitystatus = Titular {0} editado. Novo estado: {1}.
ra.editedentity = Titular {0} editado.
ra.erroreditentity = Erro editando titular {0}.
ra.removedentity = Titular {0} removido.
ra.errorremoveentity = Erro removendo titular {0}.
ra.editpwdentity = Senha alterada para titular {0}.
ra.revokedentity = Titular {0} revogado.
ra.revokedentitycert = Certificado de titular revogado. Emissor {0}, número de série {1}.
ra.errorfindentitycert = Não foi possível procurar certificado de titular. Emissor {0}, número de série {1}.
ra.errorunrevokenotonhold = Apenas é permitido reativar certificados suspensos. Emissor {0}, número de série {1}.
ra.errornotificationnoemail = Notificação não pode ser enviada para utilizador {0} porque o campo email não está preenchido.
ra.sentnotification = Enviada notificação para utilizador {0} com email {1} com sucesso.
ra.errorsendnotification = Erro enviando notificação para utilizador {0} com email {1}.
ra.extendedinfoupgrade = Atualizando informação adicional para versão {0}.
ra.eeprofileupgrade = Atualizando perfil de titular para versão {0}.
ra.eeprofileaddfield = A adicionar novo campo {0} ao NUMBERARRAY.
ra.eeprofilenonimpl = isFieldImplemented foi chamado para campo não implementado: {0}. 
ra.errorbadrequest = A ação pedida não pôde ser executada.
ra.errorcustomrcptshort = Destinatário da notificação personalizada especificado, mas valor é demasiado curto: {0}.
ra.errorcustomnoemail = Destinatário da notificação personalizada especificado, mas nenhum não foi obtido nenhum endereço de email: {0}.
ra.errorcustomnoclasspath = Destinatário da notificação personalizada especificado, mas classpath é vazia: {0}.

userdatasource.fetcheduserdatasource = Dados de utilizador obtidos com sucesso da fonte de dados de utilizadores {0}.
userdatasource.errorfetchuserdatasource = Erro obtendo fetching dados da fonte de dados de utilizadores {0}.
userdatasource.removeduserdata = Dados de utilizador removidos com sucesso da fonte de dados de utilizadores {0}.
userdatasource.errorremovinguserdatasource = Erro removendo dados da fonte de dados de utilizadores {0}.
userdatasource.erroruserdatasourceexist = Fonte de dados de utilizadores com ID {0} inexistente.
userdatasource.errornotauth = Erro: não autorizado a aceder é fonte de dados de utilizadores {0}.
userdatasource.errorfindingall = Erro procurando em todas as fontes de dados de utilizadores.
userdatasource.testedcon = Ligação a fonte de dados de utilizadores {0} testada com sucesso. 
userdatasource.errortestcon = Erro a testar ligação a fonte de dados de utilizadores {0}.
userdatasource.errortestconauth = Erro: não autorizado a testar fonte de dados de utilizadores {0}.
userdatasource.addedsource = Adicionada fonte de dados de utilizadores {0}.
userdatasource.erroraddsource = Erro adicionando fonte de dados de utilizadores {0}.
userdatasource.changedsource = Alterada fonte de dados de utilizadores {0}.
userdatasource.errorchangesource = Erro alterando fonte de dados de utilizadores {0}.
userdatasource.clonedsource = Adicionada fonte de dados de utilizadores {0} usando {1} como modelo.
userdatasource.errorclonesource = Erro adicionando fonte de dados de utilizadores {0} usando {1} como modelo.
userdatasource.removedsource = Removida fonte de dados de utilizadores {0}.
userdatasource.errorremovesource = Erro removendo fonte de dados de utilizadores {0}.
userdatasource.renamedsource = Fonte de dados de utilizadores {0} renomeada para {1}.
userdatasource.errorrenamesource = Erro renomeando fonte de dados de utilizadores {0} para {1}.


sernogenerator.discarding = Descartando número de série fora do intervalo permitido.

caservice.notactive = Serviço de AC não ativado. Active-o na página de edição da AC.
ocspcaservice.upgrade = Atualizando serviço de OCSP para versão {0}.

catoken.deativate = Desativando token de AC.
catoken.ativated = Ativado token de AC do tipo {0}.
catoken.inforegisterclasspath = Não é possível registar {0}. Normalmente não é considerado um erro.
catoken.classnotfound = Classe em falta: {0}.
catoken.errorinstansiate = Não é possível instanciar {0}. {1}.
catoken.upgrade = Atualizando token de AC para versão {0}.
catoken.errorativate = Erro ativando token de AC: {0}.
catoken.deletecert = Certificado removido '{0}'.
catoken.errornocertalias = Certificado '{0}' não encontrado na keystore.
catoken.errornokeyalias = Chave '{0}' não encontrada na keystore.
catoken.errorcertreqverify = Requisição de certiicados não está verificando.
catoken.errorkeynottoken = Chave não está no token.
catoken.genkeysnotavail = Gerar chaves (GenerateKeys) é disponível apenas para AC de tokens soft (PKCS12).
catoken.generatedkeys = Novas chaves geradas para token da AC {0}.

certprofile.upgrade = Atualizando perfil de certificado com versão {0}.

publisher.upgrade = Atualizando publicador LDAP para versão {0}.
publisher.entryexists = Entrada duplicada. Atualizando: {0}
publisher.noentry = Não existem entradas prévias para {0}.
publisher.infoexists = Já existe uma entrada com DN '{0}'  
publisher.errorextocsppubl = ERRO OCSP EXTERNO, publicação não está a funcionar para {0}.
publisher.notpublwithstatus = Certificado revogado não publicado. Estado={0}.
publisher.notpubltype = Certificado do tipo '{0}' não será publicado.
publisher.errorldapdecode = ERRO LDAP: Erro a descodificar {0}.
publisher.errorldapencodestore = ERRO LDAP: Erro a codificar {0} armazenando em LDAP.
publisher.ldapadd = LDAP {0}: Adicionado objeto: {1} com sucesso.
publisher.ldapmodify = LDAP {0}: Modificado objeto: {1} com sucesso.
publisher.ldapremove = REVOGAÇÃO LDAP: Certificado removido do objeto: {0} com sucesso.
publisher.ldapaddedintermediate = LDAP {0}: Foram criados nodos intermédios para {1}.
publisher.errorldapstore = ERRO LDAP: Erro guardando {0} ({1}) em LDAP ({2}) para DN ({3}).
publisher.errorldapremove = ERRO LDAP: Erro removendo certificado do LDAP ({0}).
publisher.errorldapintermediate = ERRO LDAP: não foi possível criar nodo '{0}' no LDAP.
publisher.ldapintermediatenotappropriate = LDAP: campo '{0}' não é apropriado para nodo intermédio.
publisher.errorpassword = ERRO LDAP: Não foi possível descodificar a senha de login no LDAP: {0}.
publisher.errordisconnect = ERRO LDAP: Publicador LDAP: Falha na desconexão LDAP.
publisher.errorrevokenoentry = ERRO LDAP: Não existe nenhuma entrada com o certificado no LDAP.
publisher.inforevokenocert = Tentativa de remoção do certificado do LDAP, mas não existe atributo de certificado na entrada.
publisher.errorldapbind = ERRO LDAP: Erro associando ao servidor de LDAP. {0}
publisher.errornobinddn = ERRO LDAP: Não foi possível encontrar o bindDN.
publisher.errortempfile = Não foi possível escrever no arquivo temporário.
publisher.errormissingproperty = {0} tem de ser especificado.
publisher.errorexternalapp = Detectados erros ao executar a aplicação externa {0}.  
publisher.errordeletetempfile = Não foi possível remover o arquivo temporário {0}.
publisher.errorcertconversion = Não foi possível converter o certificado para publicação.
publisher.commandnotfound = Não foi possível encontrar o comando externo {0}.

cmp.errorunknownprotalg = Recebida mensagem CMP com algoritmo de proteção desconhecido: {0}.
cmp.errorcertconfirmstatus = Recebida confirmação de certificado com estado {0}.
cmp.receivedmsg = Recebida mensagem CMP de: {0}.
cmp.sentresponsemsg = Enviada resposta CMP para: {0}.
cmp.receivedrevreq = Recebido pedido de revogação para emissor: {0} e número de série: {1}.
cmp.receivedrevreqnoissuer = Recebido pedido de revogação com emissor ou número de série em falta.
cmp.errornullresp = Processador de mensagens CMP devolveu uma resposta vazia.
cmp.errortcptoolongmsg = Recebida mensagem com {0} bytes, que é demasiado grande para ser considerada válida.
cmp.errortcpwronglen = Recebida mensagem com {0} bytes, que declara conter {1} bytes.
cmp.erroradduserupdate = Não foi possível adicionar o utilizador '{0}', apesar de não existir há apenas uma fração de tempo atrás! Em alternativa, será atualizado.
cmp.erroradduser = Erro adicionando utilizador '{0}'.
cmp.errorgeneral = Erro durante processamento CMP. {0}.
cmp.errorauthmessage = Autenticação falhada para mensagem.
cmp.errorcalcprotection = Erro calculando proteção.
cmp.errorunauthmessagera = Recebida mensagem não-autenticada em modo RA.
cmp.infonouserfordn = Não foi encontrado utilizador com DN que corresponda a {0}.
cmp.errornocmrfreq = ICmpMessage não é CrmfRequestMessage.
cmp.errornullresp = Resposta de signSession é vazia.
cmp.receivedrevreq = Recebido pedido de revogação para emissor: {0} e número de série: {1}.
cmp.errornotauthrevoke = Não autorizado revogando certificado com emissor: {0} e número de série: {1}.
cmp.errorcertnofound = Certificado não encontrado com emissor: {0} e número de série: {1}.
cmp.errormissingissuerrevoke = Recebido pedido de revogação com falta de emissor ou número de série.
cmp.errorrevoke = Erro revogando certificado.
cmp.errornoprot = Sem proteção PKI parverificando.
cmp.erroralreadyrequested = O pedido já está a aguardar aprovação. 
cmp.erroralreadyrevoked = Já revogado. 

ocsp.receivedunidreq = Pedido recebido (ip;fqdn): {0}; {1} para Fnr mapeado para Unid={2}.
ocsp.errordatabaseunid = Ocorreu um erro na base de dados ao procurar mapeamento para Unid-Fnr.
ocsp.errorunidnosnindn = Não foi encontrado um número de série no DN: {0}.
ocsp.errorunidnosnmapping = Não existe nenhum mapeamento Fnr para UNID {0}.
ocsp.returnedunidresponse = Devolvida resposta para (ip;fqdn): {0}; {1} com Fnr={2} para Unid={3}.
ocsp.errornoclientauth = Recebido pedido sem autenticação de cliente para (ip;fqdn): {0};{1}.
ocsp.errorverifycert = Erro a tentar verificar certificado de cliente.
ocsp.erroruntrustedclientauth = Recebido pedido com certificado não confiável desde (ip;fqdn): {0};{1}.
ocsp.errornoinitparam = Parâmetro de inicialização {0} tem de ser configurado.
ocsp.errornotrustfiles = Nenhum arquivo no diretório trustDir: {0}.
ocsp.errorreadingtrustfiles = Erro lendo arquivos do diretório trustDir: {0}.
ocsp.errorreadingfile = Erro lendo {0} de {1}: {2}.
ocsp.certcollectionempty = A coleção de certificados é vazia.
ocsp.errorcomparehash = Exceção OCSP comparando hashes de certificados, saltar certificado de AC para '{0}'.
ocsp.nomatchingcacert = Não foi encontrado nenhum certificado de AC que faça correspondência com o DN: {0}.
ocsp.reloadkeys = A recarregar chaves devido a pedido de {0}.
ocsp.errorunsignedreq = Pedido OCSP não assinado. Servlet obriga a assinatura.
ocsp.errorinvalidsignature = Assinatura do pedido de OCSP recebido é inválida.
ocsp.infosigner = Pedido OCSP foi assinado por '{0}'.
ocsp.infosigner.invalidcertsignature = Falha na verificação do certificado de assinatura para (subjectDN '{0}', issuer DN '{1}'). Mensagem\: {2}. 
ocsp.infosigner.certnotyetvalid = Assinatura do certificado ainda não é válida para (subjectDN '{0}', issuer DN '{1}') falhou. Mensagem\: {2}.
ocsp.infosigner.certexpired = Assinatuda do certificado expirou para (subjectDN '{0}', issuer DN '{1}') falhou. Mensagem\: {2}.
ocsp.infosigner.nocacert = Não foi encontrado nenhum certificado de emissor para o certificado de assinatura com DN de sujeito '{0}' e DN de emissor '{1}'.
ocsp.infosigner.revoked = Certificado de assinatura para '{0}' está revogado. DN do emissor '{1}', número de série {2}.
ocsp.infosigner.notallowed = Assinador do certificado para '{0}' não está autorizado devido a restrições no assinador ou no emissor. IssuerDN '{1}', serialNo {2}.
ocsp.errornoreqentities = O pedido de OCSP não contém nenhuma entidade simpleRequest.
ocsp.errortoomanyreqentities = O pedido OCSP contêm demasiadas entidades simpleRequest. Permitido máximo de {0}.
ocsp.errorgencerthash = Incapaz de gerar hash do certificado da AC.
ocsp.errorfindcacert = Incapaz de encontrar certificado da AC por hash do nome do emissor {0} ou mesmo do processador geral: {1}.
ocsp.errorfindcacertusedefault = Incapaz de encontrar certificado da AC por hash do nome do emissor: {0}. A usar processador geral para responder 'UnknownStatus'.
ocsp.errorprocessextension = Ocorreu um erro processando classe de extensão ao OCSP {0}. Côdigo de erro {1}.
ocsp.errornocacreateresp = Incapaz de encontrar certificado e chave da AC pargerando resposta OCSP.
ocsp.errorprocessreq = Erro processando pedido OCSP.
ocsp.classnotfound = Não foi possível carregar classe {0}.
ocsp.nocardpwd = Não foi especificada senha do cartão. 
ocsp.nohwsigningclass = Classe de assinatura do hardware OCSP não foi definida.
ocsp.errornovalidkeys = Não foram especificadas chaves válidas.
ocsp.errorinitialize = Não foi possível inicializar OCSPServlet.
ocsp.signcertnotindb = Certificado de assinatura com número de série {0} do emissor {1} não foi encontrado na base de dados (certificados de assinatura e AC têm de ser publicados no OCSP).
ocsp.signcertrevoked = Certificado de assinatura com número de série {0} do emissor {1} está revogado.
ocsp.signcerthasnochain = Certificado de assinatura com número de série {0} do emissor {1} não tem a cadeia de certificação até é AC de raíz.
ocsp.errorgetalias = Incapaz de encontrar o nome {0} no arquivo {1}.
ocsp.newsigningkey = Nova chave de assinatura OCSP para a AC '{0}'. Certificado da chave '{1}'.
ocsp.errorocspkeynotusable = Chave de assinatura OCSP inutilizável para AC '{0}'. Certificate da chave com número de série: {1}.
ocsp.errorloadsigningcerts = Incapaz de carregar certificados de assinatura.
ocsp.infoaddedstatusinfo = A adicionar informação de estado ({0}) para certificado com número de série '{1}' do emissor '{2}'.
ocsp.inforeceivedrequest = Recebido pedido OCSP para certificado com número de série: {0} e hash do nome do emissor: {1}.

scep.errormissingparam = Recebido pedido com parâmetros em falta de {0}. Parâmetros 'operation' e 'message' têm de ser fornecidos.
scep.receivedmsg = Recebida mensagem SCEP de {0}.
scep.sentresponsemsg = Enviada resposta SCEP {0} para {1}.
scep.errorunknownca = Pedido SCEP {0} para AC desconhecida '{1}'.
scep.errorinvalidreq = Recebido pedido inválido ou vazio.
scep.errorauth = Autorização negada.
scep.errorclientstatus = Estado inválido do cliente.
scep.errorgeneral = Erro processando pedido SCEP.

batch.createkeystore = Keystore criada para '{0}'.
batch.errornokeyrecoverydata = Não existem dados de recuperação de chave para o utilizador '{0}'; não pode ser obtido.
batch.retrieveingkeys = Obtendo chaves para {0}.
batch.generatingkeys = Gerando chaves para {0}.
batch.generateduser = Gerado novo utilizador com sucesso - {0}.
batch.generatingallstatus = Gerando para todos {0}.
batch.generatingnoofusers = Geração em lote para {0} utilizadores.
batch.errorsetstatus = Ocorreu um erro; mudança de estado para {0}.
batch.infonoclearpwd = Utilizador '{0}' não tem a senha em claro.
batch.errorbatchfailed = BatchMakeP12 falhou para {0} utilizadores ({1} com sucesso) - {0}.
batch.errorbatchfaileduser = BatchMakeP12 falhou para '{0}'.
batch.success = {0} novos utilizadores gerados com sucesso - {1}.
batch.generateindir = Gerando chaves no diretório {0}.
batch.errorunknown = Utilizador desconhecido ou senha em claro é vazia: {0}.
batch.errorrootnotverify = Certificado RootCA falha a validação.
batch.errorrootnotselfsigned = Certificado RootCA não é auto-assinado.
batch.errorgennotverify = Certificado gerado falha a validação contra o certificado da AC.

certreq.sentlatestcertreq = Enviado último pedido de certificado para o cliente em {0}.
certreq.errorsendlatestcertreq = Erro enviando pedido de certificado para {0}.
certreq.errorsendcert = Erro no envio de certificado processado para {0}; causa: {1}.
certreq.sentlatestcrl = Enviada última CRL para cliente em {0}.
certreq.errorsendcrl = Erro enviando CRL para {0}; causa: {1}.
certreq.receivedcertreq = Pedido de certificado recebido para o utilizador '{0}' de {1}.

healthcheck.allipsauthorized = Todo os IPs autorizados.
healthcheck.errorauth = ERRO : recebido pedido Healthcheck de IP não autorizado: {0}.

startservice.shutdown = Final, desligando o EJBCA.
startservice.startup = Início, iniciando o EJBCA.
startservice.waitservicever= Esperando até {0} segundos para serviço de verificação terminar.
startservice.waitserviceexp= Esperando até {0} segundos para serviço de exportação terminar.

xkms.errorregisteringnamespace = Erro registrando propriedade de mapeamento do namespace
xkms.errorinitializinggenerator = Erro iniciando RequestAbstractTypeResponseGenerator
xkms.errorparsingdomreq = Erro interpretando DOM do pedido.
xkms.errorunmarshallingreq = Erro desempacotar pedido
xkms.errorparsingresp = Erro interpretando resposta
xkms.recievedreqwithoutsig = Pedido XKMS recebido sem assinatura, que é obrigatôria
xkms.errorreqsigdoesntverify = Assinatura do pedido XKMS não verifica
xkms.errorwhenverifyingreq = Erro verificando assinatura do pedido.
xkms.errorgenrespsig = Erro gerando assinatura da resposta a pedido XKMS
xkms.errorinitadminsession = Erro instanciando User Admin Session Bean
xkms.errorinitauthsession = Erro instanciando Authorization Session Bean
xkms.errorinitkeyrecsession = Erro instanciando Key Recovery Session Bean
xkms.errorinitauthentsession = Erro instanciando Authentication Session Bean
xkms.errordecodingcert = Erro descodificando certificado
xkms.errorcreatesession = Erro criando beans de sessão.
xkms.illegaluserquery = Query de utilizadores não permitida
xkms.errorextractingusekeywith = Erro extraindo atributos UseKeyWith do certificado
xkms.errorregisteringreq = Erro registrando pedido XKMS
xkms.errorinreqwrongstatus = Erro no pedido XKMS; estado inválido {0} para utilizador {1}
xkms.errorinprivs = O administrador não tem privilégios suificientes para encontrar o utilizador
xkms.errorfindinguserdata = Erro procurando dados de utilizador para certificado com DN : {0}
xkms.errorauthverification = Erro efetuando verificação de autenticação :
xkms.errorverifyingcert = Erro verificando certificado :
xkms.errorsettinguserstatus = Erro atribuindo ao utilizador estado novo : {0}
xkms.errorgenrespid = Erro gerando ID da resposta
xkms.onlyrsakeysupported = Apenas são suportadas chaves RSA.
xkms.errorfetchinglastcrl = Erro obtendo a última CRL
xkms.errorextractingusekeyattr = Erro extraindo atributos de utilização da chave a partir do certificado
xkms.errorsetvalidityinterval = Erro definindo intervalo de validade

certext.errorparsingproperty= Erro interpretando o arquivo '/certextensions.properties'
certext.certextmissconfigured = Extensão de Certificado {0} parece não estar configurada corretamente no arquivo certextensions.properties
certext.noextensionforid = Nenhuma extensão configurada para ID: {0}. A devolver null.
certext.basic.incorrectvalue= Propriedade 'value' incorrecta para extensão de certificado básica com id : {0}
certext.basic.incorrectenc= Codificação incorrecta para extensão de certificado básica com id : {0}
certext.basic.illegalvalue = Valor inválido {0} para extensão de certificado básica com id : {1}

# Messages used by the log system itself
log.nouserinvolved = Nenhum utilizador envolvido
log.nocertinvolved = Nenhum certificado envolvido
log.adminnotknown = Administrador desconhecido

# General error messages, used in several places
error.catokenoffline = Token da AC {0} está desativado.
error.unknown = Erro desconhecido.

APACTIVATECATOKEN         = ativar Token da AC

APADDENDENTITY            = adicionar Titular

APCHANGESTATUSENDENTITY   = alterar estado de titular

APEDITENDENTITY           = editar titular

APVIEWHARDTOKENDATA       = ver dados de hard token

APKEYRECOVERY             = recuperação de chave

APGENERATETOKEN           = gerar token

APREVOKEENDENTITY         = revogar titular

APREVOKEDELETEENDENTITY   = revogar e remover titular

APREVOKECERTIFICATE       = revogar ou reativar certificado

CLITOOL                   = Ferramenta de Linha de Comando
