/*************************************************************************
 *                                                                       *
 *  EJBCA: The OpenSource Certificate Authority                          *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.ejbca.core.ejb.log;

import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;

import javax.ejb.CreateException;

import org.ejbca.core.ejb.BaseEntityBean;
import org.ejbca.util.Base64;
import org.ejbca.util.CertTools;
import org.ejbca.util.GUIDGenerator;

/** Entity bean should not be used directly, use though Session beans.
*
* Entity Bean representing a ProtectedLogToken in the database.
* Information stored:
* <pre>
*  pk (Primary Key) is a 32 byte GUID generated by org.ejbca.util.GUIDGenerator
*  tokenIdentifier is the key identifier
*  tokenType is an enumerated keytype
*  b64TokenCertificate is the certificate that can be used to validate the key
*  tokenReference is depending on the keyType this can be an URI, a CA-Id or base64-encoded raw key data.
* </pre>
*
* @ejb.bean
*   description="This enterprise bean entity represents a ProtectedLogToken with accompanying data"
*   display-name="ProtectedLogTokenDataEB"
*   name="ProtectedLogTokenData"
*   jndi-name="ProtectedLogTokenData"
*   view-type="local"
*   type="CMP"
*   reentrant="False"
*   cmp-version="2.x"
*   transaction-type="Container"
*   schema="ProtectedLogTokenDataBean"
*   primkey-field="pk"
*
* @ejb.pk
*   generate="false"
*   class="java.lang.String"
*
* @ejb.persistence table-name = "ProtectedLogTokenData"
* 
* @ejb.home
*   generate="local"
*   local-extends="javax.ejb.EJBLocalHome"
*   local-class="org.ejbca.core.ejb.log.ProtectedLogTokenDataLocalHome"
*
* @ejb.interface
*   generate="local"
*   local-extends="javax.ejb.EJBLocalObject"
*   local-class="org.ejbca.core.ejb.log.ProtectedLogTokenDataLocal"
*
* @ejb.transaction type="Required"
* 
* @ejb.finder
*   description="findByTokenIdentifier"
*   signature="org.ejbca.core.ejb.log.ProtectedLogTokenDataLocal findByTokenIdentifier(int tokenIdentifier)"
*   query="SELECT OBJECT(a) from ProtectedLogTokenDataBean a WHERE a.tokenIdentifier=?1"
*
* @jboss.method-attributes
*   pattern = "get*"
*   read-only = "true"
*   
* @jboss.method-attributes
*   pattern = "find*"
*   read-only = "true"
*   
* @jonas.jdbc-mapping
*   jndi-name="${datasource.jndi-name}"
*/
public abstract class ProtectedLogTokenDataBean extends BaseEntityBean {

    /**
    * @ejb.create-method view-type="local"
    */
   public String ejbCreate(int tokenIdentifier, int tokenType, Certificate tokenCertificate, String tokenReference) throws CreateException {
       setPk(GUIDGenerator.generateGUID(this));
       setTokenIdentifier(tokenIdentifier);
       setTokenType(tokenType);
       setTokenCertificate(tokenCertificate);
       setTokenReference(tokenReference);
       return null;
   }

   public void ejbPostCreate(int tokenIdentifier, int tokenType, Certificate tokenCertificate, String tokenReference) {
   }

    /**
     * @ejb.pk-field
     * @ejb.persistence column-name="pk"
     * @ejb.interface-method
     */
    public abstract String getPk();
    public abstract void setPk(String pk);

    /**
     * @ejb.persistence column-name="tokenIdentifier"
     * @ejb.interface-method
     */
    public abstract int getTokenIdentifier();
    public abstract void setTokenIdentifier(int tokenIdentifier);

    /**
     * @ejb.persistence column-name="tokenType"
     * @ejb.interface-method
     */
    public abstract int getTokenType();
    public abstract void setTokenType(int tokenType);
	
    /**
     * @ejb.persistence jdbc-type="LONGVARCHAR" column-name="b64TokenCertificate"
     * @ejb.interface-method
     */
    public abstract String getB64TokenCertificate();
    public abstract void setB64TokenCertificate(String b64TokenCertificate);

    /**
     * @ejb.persistence jdbc-type="LONGVARCHAR" column-name="tokenReference"
     * @ejb.interface-method
     */
    public abstract String getTokenReference();
    public abstract void setTokenReference(String tokenReference);

    /**
     * @return certificate
     * @ejb.interface-method
     */
    public Certificate getTokenCertificate() {
        try {
        	String b64TokenCertificate = getB64TokenCertificate();
        	if (b64TokenCertificate != null) {
            	return CertTools.getCertfromByteArray(Base64.decode(b64TokenCertificate.getBytes()));
        	} else {
        		return null;
        	}
        } catch (CertificateException ce) {
            log.error("Can't decode certificate.", ce);
        }
		return null;
    }

    /**
     * @param tokenCertificate certificate
     * @ejb.interface-method
     */
    public void setTokenCertificate(Certificate tokenCertificate) {
        try {
        	String b64Cert = null;
        	if (tokenCertificate != null) {
        		b64Cert = new String(Base64.encode(tokenCertificate.getEncoded(), false));
        	}
            setB64TokenCertificate(b64Cert);
        } catch (CertificateEncodingException cee) {
            log.error("Can't extract DER encoded certificate information.", cee);
        }
    }
}
